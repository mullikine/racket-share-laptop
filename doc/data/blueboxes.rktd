12349
((3) 0 () 12 ((q lib "data/integer-set.rkt") (q lib "data/order.rkt") (q lib "data/enumerate/lib.rkt") (q lib "data/queue.rkt") (q lib "data/enumerate.rkt") (q lib "data/skip-list.rkt") (q lib "data/splay-tree.rkt") (q lib "data/heap.rkt") (q lib "data/interval-map.rkt") (q lib "data/bit-vector.rkt") (q lib "data/gvector.rkt") (q lib "data/union-find.rkt")) () (h ! (equal) ((c def c (c (? . 0) q split)) q (16010 . 4)) ((c def c (c (? . 4) q enum-count)) q (19426 . 3)) ((c def c (c (? . 2) q infinite-sequence/e)) q (28337 . 3)) ((c def c (c (? . 6) q splay-tree->list)) q (7094 . 3)) ((c def c (c (? . 3) q make-queue)) q (0 . 2)) ((c def c (c (? . 0) q complement)) q (16126 . 5)) ((c def c (c (? . 1) q order)) q (3447 . 12)) ((c def c (c (? . 8) q interval-map-iterate-next)) q (13417 . 6)) ((c def c (c (? . 1) q dict-iterate-least/>=?)) q (3034 . 5)) ((c def c (c (? . 2) q exact-rational/e)) q (29611 . 3)) ((c def c (c (? . 11) q uf-set-canonical!)) q (19002 . 4)) ((c def c (c (? . 1) q dict-iterate-least)) q (2679 . 3)) ((c def c (c (? . 5) q skip-list-iterate-key)) q (9067 . 4)) ((c def c (c (? . 3) q nonempty-queue/c)) q (770 . 2)) ((c def c (c (? . 1) q order?)) q (3925 . 3)) ((c def c (c (? . 4) q flat-enum?)) q (19370 . 3)) ((c def c (c (? . 2) q non-empty-listof/e)) q (25903 . 8)) ((c def c (c (? . 0) q integer-set?)) q (15414 . 3)) ((c def c (c (? . 5) q skip-list-iterate-least/>=?)) q (9445 . 5)) ((c def c (c (? . 5) q skip-list-expand!)) q (8658 . 5)) ((c def c (c (? . 5) q skip-list-count)) q (8267 . 3)) ((c def c (c (? . 6) q splay-tree-iterate-first)) q (5492 . 3)) ((c def c (c (? . 9) q string->bit-vector)) q (18598 . 3)) ((c def c (c (? . 4) q to-nat)) q (19726 . 6)) ((c form c (c (? . 10) q for*/gvector)) q (2382 . 2)) ((c def c (c (? . 7) q heap-remove-min!)) q (14467 . 3)) ((c def c (c (? . 2) q take/e)) q (26621 . 9)) ((c def c (c (? . 5) q skip-list?)) q (7747 . 3)) ((c def c (c (? . 6) q splay-tree-ref)) q (5053 . 5)) ((c def c (c (? . 5) q skip-list-iterate-value)) q (9187 . 4)) ((c def c (c (? . 5) q skip-list-iterate-greatest)) q (10053 . 4)) ((c def c (c (? . 7) q heap-count)) q (14167 . 3)) ((c def c (c (? . 3) q in-queue)) q (673 . 3)) ((c def c (c (? . 1) q ordered-dict?)) q (2620 . 3)) ((c def c (c (? . 2) q slice/e)) q (26931 . 14)) ((c def c (c (? . 8) q interval-map-ref/bounds)) q (11115 . 10)) ((c def c (c (? . 6) q adjustable-splay-tree?)) q (4985 . 3)) ((c def c (c (? . 5) q skip-list-remove!)) q (8163 . 4)) ((c form c (c (? . 9) q for*/bit-vector)) q (18253 . 3)) ((c def c (c (? . 2) q flip-dep/e)) q (24596 . 20)) ((c def c (c (? . 0) q partition)) q (16680 . 3)) ((c def c (c (? . 8) q interval-map-expand!)) q (12691 . 7)) ((c def c (c (? . 9) q bit-vector)) q (17044 . 3)) ((c def c (c (? . 9) q bit-vector-popcount)) q (17643 . 3)) ((c def c (c (? . 2) q bool/e)) q (29334 . 2)) ((c def c (c (? . 8) q interval-map-iterate-value)) q (13796 . 5)) ((c def c (c (? . 8) q interval-map-iter?)) q (13976 . 3)) ((c form c (c (? . 9) q for/bit-vector)) q (17997 . 9)) ((c def c (c (? . 2) q nat+/e)) q (27888 . 3)) ((c def c (c (? . 1) q dict-iterate-greatest)) q (2787 . 4)) ((c def c (c (? . 5) q skip-list-iterate-first)) q (8814 . 3)) ((c def c (c (? . 1) q dict-iterate-greatest/<=?)) q (3308 . 5)) ((c def c (c (? . 1) q order-comparator)) q (3977 . 3)) ((c def c (c (? . 4) q enum-contract)) q (19489 . 3)) ((c def c (c (? . 6) q splay-tree-remove-range!)) q (5935 . 5)) ((c def c (c (? . 10) q gvector-count)) q (1938 . 3)) ((c def c (c (? . 1) q real-order)) q (4297 . 2)) ((c def c (c (? . 6) q splay-tree-iterate-greatest/<=?)) q (6905 . 5)) ((c def c (c (? . 1) q order-domain-contract)) q (4066 . 3)) ((c def c (c (? . 2) q fin/e)) q (27494 . 3)) ((c def c (c (? . 6) q splay-tree-iterate-least/>=?)) q (6655 . 5)) ((c def c (c (? . 4) q map/e)) q (20625 . 13)) ((c def c (c (? . 5) q skip-list-iter-valid?)) q (10227 . 3)) ((c def c (c (? . 5) q skip-list-ref)) q (7870 . 5)) ((c def c (c (? . 7) q in-heap)) q (14955 . 3)) ((c def c (c (? . 2) q char/e)) q (29198 . 2)) ((c def c (c (? . 10) q gvector-remove!)) q (1699 . 5)) ((c def c (c (? . 2) q hash-traverse/e)) q (28414 . 9)) ((c def c (c (? . 4) q in-enum)) q (20141 . 3)) ((c def c (c (? . 1) q order-<?)) q (4218 . 3)) ((c def c (c (? . 2) q range/e)) q (27695 . 5)) ((c def c (c (? . 8) q interval-map-set!)) q (11448 . 9)) ((c def c (c (? . 3) q queue-empty?)) q (500 . 3)) ((c def c (c (? . 10) q gvector?)) q (987 . 3)) ((c def c (c (? . 2) q listof-n/e)) q (26177 . 6)) ((c def c (c (? . 3) q enqueue-front!)) q (106 . 4)) ((c def c (c (? . 9) q bit-vector-ref)) q (17174 . 5)) ((c def c (c (? . 2) q vector/e)) q (27987 . 4)) ((c def c (c (? . 1) q datum-order)) q (4325 . 2)) ((c def c (c (? . 7) q in-heap/consume!)) q (14886 . 3)) ((c def c (c (? . 6) q splay-tree-remove!)) q (5316 . 4)) ((c def c (c (? . 5) q skip-list-iter?)) q (10166 . 3)) ((c def c (c (? . 5) q skip-list-iterate-least/>?)) q (9309 . 5)) ((c def c (c (? . 5) q skip-list-remove-range!)) q (8367 . 5)) ((c def c (c (? . 2) q string/e)) q (29264 . 2)) ((c def c (c (? . 7) q heap-sort!)) q (15015 . 4)) ((c def c (c (? . 6) q splay-tree-iterate-value)) q (5826 . 4)) ((c def c (c (? . 11) q uf-union!)) q (18846 . 4)) ((c def c (c (? . 2) q two-way-real/e)) q (29690 . 2)) ((c form c (c (? . 10) q for/gvector)) q (2330 . 2)) ((c def c (c (? . 8) q interval-map-contract!)) q (12445 . 7)) ((c def c (c (? . 11) q uf-set?)) q (18741 . 3)) ((c def c (c (? . 7) q heap-add!)) q (14241 . 4)) ((c def c (c (? . 5) q skip-list-iterate-greatest/<?)) q (9582 . 6)) ((c def c (c (? . 6) q splay-tree-iterate-next)) q (5588 . 4)) ((c def c (c (? . 4) q two-way-enum?)) q (19252 . 3)) ((c def c (c (? . 10) q in-gvector)) q (2268 . 3)) ((c def c (c (? . 9) q bit-vector->string)) q (18504 . 3)) ((c def c (c (? . 2) q permutations/e)) q (28232 . 3)) ((c def c (c (? . 0) q foldr)) q (16538 . 5)) ((c def c (c (? . 4) q append/e)) q (21742 . 5)) ((c def c (c (? . 4) q dep/e)) q (23122 . 20)) ((c def c (c (? . 3) q queue?)) q (559 . 3)) ((c def c (c (? . 10) q gvector-remove-last!)) q (1870 . 3)) ((c def c (c (? . 1) q order-=?)) q (4139 . 3)) ((c def c (c (? . 0) q member?)) q (16364 . 4)) ((c def c (c (? . 10) q list->gvector)) q (2209 . 3)) ((c def c (c (? . 9) q list->bit-vector)) q (18420 . 3)) ((c def c (c (? . 10) q make-gvector)) q (812 . 3)) ((c def c (c (? . 6) q splay-tree-iterate-key)) q (5719 . 4)) ((c def c (c (? . 4) q or/e)) q (21566 . 4)) ((c def c (c (? . 7) q heap->vector)) q (14777 . 3)) ((c def c (c (? . 6) q splay-tree-contract!)) q (6054 . 5)) ((c def c (c (? . 9) q bit-vector-copy)) q (17734 . 5)) ((c def c (c (? . 4) q thunk/e)) q (21965 . 19)) ((c def c (c (? . 2) q single/e)) q (27575 . 4)) ((c def c (c (? . 8) q interval-map-iterate-first)) q (13292 . 4)) ((c def c (c (? . 4) q bounded-list/e)) q (24002 . 5)) ((c def c (c (? . 3) q non-empty-queue?)) q (611 . 3)) ((c def c (c (? . 6) q splay-tree-iter?)) q (7032 . 3)) ((c def c (c (? . 4) q below/e)) q (20266 . 7)) ((c def c (c (? . 1) q ordering/c)) q (2435 . 2)) ((c def c (c (? . 0) q subtract)) q (15831 . 4)) ((c def c (c (? . 7) q vector->heap)) q (14669 . 4)) ((c def c (c (? . 3) q dequeue!)) q (183 . 3)) ((c def c (c (? . 5) q make-skip-list)) q (7169 . 7)) ((c def c (c (? . 5) q skip-list->list)) q (10310 . 3)) ((c def c (c (? . 3) q queue/c)) q (737 . 2)) ((c def c (c (? . 7) q heap-remove!)) q (14526 . 5)) ((c def c (c (? . 8) q interval-map-update*!)) q (11742 . 11)) ((c def c (c (? . 2) q set/e)) q (28289 . 3)) ((c def c (c (? . 6) q splay-tree?)) q (4928 . 3)) ((c def c (c (? . 0) q set-integer-set-contents!)) q (15305 . 4)) ((c def c (c (? . 9) q bit-vector->list)) q (18340 . 3)) ((c def c (c (? . 2) q number/e)) q (29913 . 2)) ((c def c (c (? . 11) q uf-new)) q (18690 . 3)) ((c def c (c (? . 2) q flonum/e)) q (29541 . 2)) ((c def c (c (? . 4) q enum->list)) q (19923 . 6)) ((c def c (c (? . 8) q interval-map-iterate-key)) q (13618 . 5)) ((c def c (c (? . 4) q pam/e)) q (21169 . 6)) ((c def c (c (? . 1) q dict-iterate-least/>?)) q (2899 . 5)) ((c def c (c (? . 2) q listof/e)) q (25645 . 7)) ((c def c (c (? . 0) q count)) q (16766 . 3)) ((c def c (c (? . 6) q make-splay-tree)) q (4354 . 7)) ((c def c (c (? . 8) q interval-map-remove!)) q (12173 . 7)) ((c def c (c (? . 6) q make-adjustable-splay-tree)) q (4681 . 6)) ((c def c (c (? . 4) q enum?)) q (19083 . 3)) ((c def c (c (? . 6) q splay-tree-set!)) q (5202 . 5)) ((c def c (c (? . 4) q empty/e)) q (20558 . 2)) ((c def c (c (? . 4) q except/e)) q (21406 . 5)) ((c def c (c (? . 0) q symmetric-difference)) q (16261 . 4)) ((c form c (c (? . 2) q delay/e)) q (26319 . 7)) ((c def c (c (? . 10) q gvector-add!)) q (1199 . 4)) ((c def c (c (? . 9) q in-bit-vector)) q (17929 . 3)) ((c def c (c (? . 7) q heap-copy)) q (14834 . 3)) ((c def c (c (? . 3) q enqueue!)) q (35 . 4)) ((c def c (c (? . 7) q make-heap)) q (14040 . 3)) ((c def c (c (? . 8) q interval-map?)) q (10795 . 3)) ((c def c (c (? . 0) q make-range)) q (15534 . 7)) ((c def c (c (? . 6) q splay-tree-count)) q (5406 . 3)) ((c def c (c (? . 3) q queue->list)) q (342 . 3)) ((c def c (c (? . 0) q integer-set-contents)) q (15224 . 3)) ((c def c (c (? . 0) q get-integer)) q (16452 . 3)) ((c def c (c (? . 0) q intersect)) q (15739 . 4)) ((c def c (c (? . 0) q well-formed-set?)) q (15472 . 3)) ((c def c (c (? . 2) q fold-enum)) q (28785 . 9)) ((c def c (c (? . 4) q finite-enum?)) q (19134 . 3)) ((c def c (c (? . 10) q gvector)) q (923 . 3)) ((c def c (c (? . 2) q integer/e)) q (29470 . 2)) ((c def c (c (? . 6) q splay-tree-iterate-least)) q (6340 . 3)) ((c def c (c (? . 5) q skip-list-iterate-greatest/<=?)) q (9762 . 6)) ((c def c (c (? . 9) q bit-vector-length)) q (17554 . 3)) ((c def c (c (? . 10) q gvector-set!)) q (1496 . 6)) ((c def c (c (? . 2) q permutations-of-n/e)) q (28123 . 4)) ((c def c (c (? . 4) q list/e)) q (22988 . 4)) ((c def c (c (? . 9) q bit-vector?)) q (17117 . 3)) ((c def c (c (? . 2) q cons/e)) q (25493 . 5)) ((c def c (c (? . 7) q heap-min)) q (14416 . 3)) ((c def c (c (? . 2) q symbol/e)) q (29400 . 2)) ((c def c (c (? . 8) q interval-map-cons*!)) q (12931 . 11)) ((c def c (c (? . 5) q skip-list-iterate-next)) q (8923 . 5)) ((c def c (c (? . 5) q skip-list-iterate-least)) q (9944 . 3)) ((c def c (c (? . 1) q gen:ordered-dict)) q (2471 . 2)) ((c def c (c (? . 10) q gvector-insert!)) q (1291 . 6)) ((c def c (c (? . 10) q gvector-ref)) q (1041 . 5)) ((c def c (c (? . 2) q two-way-number/e)) q (29834 . 3)) ((c def c (c (? . 3) q queue-length)) q (415 . 3)) ((c def c (c (? . 8) q make-interval-map)) q (10399 . 9)) ((c def c (c (? . 1) q dict-iterate-greatest/<?)) q (3170 . 5)) ((c def c (c (? . 0) q make-integer-set)) q (15143 . 3)) ((c def c (c (? . 2) q real/e)) q (29766 . 2)) ((c def c (c (? . 4) q one-way-enum?)) q (19311 . 3)) ((c def c (c (? . 6) q splay-tree-iterate-greatest)) q (6435 . 3)) ((c def c (c (? . 10) q vector->gvector)) q (2085 . 3)) ((c def c (c (? . 5) q skip-list-contract!)) q (8500 . 5)) ((c def c (c (? . 4) q from-nat)) q (19555 . 6)) ((c def c (c (? . 6) q splay-tree-expand!)) q (6198 . 5)) ((c def c (c (? . 4) q infinite-enum?)) q (19192 . 3)) ((c def c (c (? . 5) q skip-list-set!)) q (8035 . 5)) ((c def c (c (? . 5) q make-adjustable-skip-list)) q (7492 . 6)) ((c form c (c (? . 2) q cons/de)) q (24128 . 12)) ((c def c (c (? . 8) q interval-map-ref)) q (10854 . 7)) ((c def c (c (? . 9) q make-bit-vector)) q (16928 . 4)) ((c def c (c (? . 2) q random-index)) q (29140 . 3)) ((c def c (c (? . 9) q bit-vector-set!)) q (17338 . 6)) ((c def c (c (? . 11) q uf-same-set?)) q (18921 . 4)) ((c def c (c (? . 1) q prop:ordered-dict)) q (2504 . 3)) ((c def c (c (? . 6) q splay-tree-iterate-least/>?)) q (6533 . 4)) ((c def c (c (? . 4) q natural/e)) q (20195 . 2)) ((c def c (c (? . 7) q heap?)) q (14116 . 3)) ((c def c (c (? . 10) q gvector->list)) q (2148 . 3)) ((c def c (c (? . 7) q heap-add-all!)) q (14317 . 4)) ((c def c (c (? . 3) q queue-filter!)) q (245 . 4)) ((c def c (c (? . 10) q gvector->vector)) q (2020 . 3)) ((c def c (c (? . 0) q union)) q (15922 . 4)) ((c def c (c (? . 6) q splay-tree-iterate-greatest/<?)) q (6779 . 5)) ((c def c (c (? . 11) q uf-find)) q (18794 . 3)) ((c def c (c (? . 0) q subset?)) q (16842 . 4)) ((c def c (c (? . 5) q adjustable-skip-list?)) q (7803 . 3))))
procedure
(make-queue) -> queue?
procedure
(enqueue! q v) -> void?
  q : queue?
  v : any/c
procedure
(enqueue-front! q v) -> void?
  q : queue?
  v : any/c
procedure
(dequeue! q) -> any/c
  q : non-empty-queue?
procedure
(queue-filter! q pred?) -> void?
  q : queue?
  pred? : (-> any/c any/c)
procedure
(queue->list queue) -> (listof any/c)
  queue : queue?
procedure
(queue-length queue) -> exact-nonnegative-integer?
  queue : queue?
procedure
(queue-empty? q) -> boolean?
  q : queue?
procedure
(queue? v) -> boolean?
  v : any/c
procedure
(non-empty-queue? v) -> boolean?
  v : any/c
procedure
(in-queue queue) -> sequence?
  queue : queue?
value
queue/c : flat-contract?
value
nonempty-queue/c : flat-contract?
procedure
(make-gvector [#:capacity capacity]) -> gvector?
  capacity : exact-positive-integer? = 10
procedure
(gvector elem ...) -> gvector?
  elem : any/c
procedure
(gvector? x) -> boolean?
  x : any/c
procedure
(gvector-ref gv index [default]) -> any/c
  gv : gvector?
  index : exact-nonnegative-integer?
  default : any/c = (error ....)
procedure
(gvector-add! gv value ...) -> void?
  gv : gvector?
  value : any/c
procedure
(gvector-insert! gv index value) -> void?
  gv : gvector
  index : (and/c exact-nonnegative-integer?
                 (</c (+ 1 (gvector-count gv))))
  value : any/c
procedure
(gvector-set! gv index value) -> void?
  gv : gvector?
  index : (and/c exact-nonnegative-integer?
                 (</c (+ 1 (gvector-count gv))))
  value : any/c
procedure
(gvector-remove! gv index) -> void?
  gv : gvector?
  index : (and/c exact-nonnegative-integer?
                 (</c (gvector-count gv)))
procedure
(gvector-remove-last! gv) -> any/c
  gv : gvector?
procedure
(gvector-count gv) -> exact-nonnegative-integer?
  gv : gvector?
procedure
(gvector->vector gv) -> vector?
  gv : gvector?
procedure
(vector->gvector v) -> gvector?
  v : vector?
procedure
(gvector->list gv) -> list?
  gv : gvector?
procedure
(list->gvector l) -> gvector?
  l : list?
procedure
(in-gvector gv) -> sequence?
  gv : gvector?
syntax
(for/gvector (for-clause ...) body ...+)
syntax
(for*/gvector (for-clause ...) body ...+)
value
ordering/c : flat-contract?
value
gen:ordered-dict : any/c
value
prop:ordered-dict : (struct-type-property/c
                     (vectorof e/c e/c s/c s/c s/c s/c))
procedure
(ordered-dict? x) -> boolean?
  x : any/c
procedure
(dict-iterate-least dict) -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
procedure
(dict-iterate-greatest dict)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
procedure
(dict-iterate-least/>? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
procedure
(dict-iterate-least/>=? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
procedure
(dict-iterate-greatest/<? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
procedure
(dict-iterate-greatest/<=? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
procedure
(order name domain-contract comparator)
 -> (and/c order? procedure?)
  name : symbol?
  domain-contract : contract?
  comparator : (-> any/c any/c ordering/c)
(order name domain-contract =? <? [>?]) -> (and/c order? procedure?)
  name : symbol?
  domain-contract : contract?
  =? : (-> any/c any/c boolean?)
  <? : (-> any/c any/c boolean?)
  >? : (-> any/c any/c boolean?) = (lambda (x y) (<? y x))
procedure
(order? x) -> boolean?
  x : any/c
procedure
(order-comparator ord) -> (-> any/c any/c ordering/c)
  ord : order?
procedure
(order-domain-contract ord) -> contract?
  ord : order?
procedure
(order-=? ord) -> (-> any/c any/c boolean?)
  ord : order?
procedure
(order-<? ord) -> (-> any/c any/c boolean?)
  ord : order?
value
real-order : order?
value
datum-order : order?
procedure
(make-splay-tree [ord                                   
                  #:key-contract key-contract           
                  #:value-contract value-contract]) -> splay-tree?
  ord : order? = datum-order
  key-contract : contract? = any/c
  value-contract : contract? = any/c
procedure
(make-adjustable-splay-tree [#:key-contract key-contract       
                             #:value-contract value-contract]) 
 -> splay-tree?
  key-contract : contract? = any/c
  value-contract : contract? = any/c
procedure
(splay-tree? x) -> boolean?
  x : any/c
procedure
(adjustable-splay-tree? x) -> boolean?
  x : any/c
procedure
(splay-tree-ref s key [default]) -> any
  s : splay-tree?
  key : any/c
  default : any/c = (lambda () (error ....))
procedure
(splay-tree-set! s key value) -> void?
  s : splay-tree?
  key : any/c
  value : any/c
procedure
(splay-tree-remove! s key) -> void?
  s : splay-tree?
  key : any/c
procedure
(splay-tree-count s) -> exact-nonnegative-integer?
  s : splay-tree?
procedure
(splay-tree-iterate-first s) -> (or/c #f splay-tree-iter?)
  s : splay-tree?
procedure
(splay-tree-iterate-next s iter) -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  iter : splay-tree-iter?
procedure
(splay-tree-iterate-key s iter) -> any/c
  s : splay-tree?
  iter : splay-tree-iter?
procedure
(splay-tree-iterate-value s iter) -> any/c
  s : splay-tree?
  iter : splay-tree-iter?
procedure
(splay-tree-remove-range! s from to) -> void?
  s : splay-tree?
  from : any/c
  to : any/c
procedure
(splay-tree-contract! s from to) -> void?
  s : adjustable-splay-tree?
  from : exact-integer?
  to : exact-integer?
procedure
(splay-tree-expand! s from to) -> void?
  s : adjustable-splay-tree?
  from : exact-integer?
  to : exact-integer?
procedure
(splay-tree-iterate-least s) -> (or/c #f splay-tree-iter?)
  s : splay-tree
procedure
(splay-tree-iterate-greatest s) -> (or/c #f splay-tree-iter?)
  s : splay-tree
procedure
(splay-tree-iterate-least/>? s key) -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
procedure
(splay-tree-iterate-least/>=? s key)
 -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
procedure
(splay-tree-iterate-greatest/<? s key)
 -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
procedure
(splay-tree-iterate-greatest/<=? s key)
 -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
procedure
(splay-tree-iter? x) -> boolean?
  x : any/c
procedure
(splay-tree->list s) -> (listof pair?)
  s : splay-tree?
procedure
(make-skip-list [ord                                   
                 #:key-contract key-contract           
                 #:value-contract value-contract]) -> skip-list?
  ord : order? = datum-order
  key-contract : contract? = any/c
  value-contract : contract? = any/c
procedure
(make-adjustable-skip-list [#:key-contract key-contract       
                            #:value-contract value-contract]) 
 -> adjustable-skip-list?
  key-contract : contract? = any/c
  value-contract : contract? = any/c
procedure
(skip-list? v) -> boolean?
  v : any/c
procedure
(adjustable-skip-list? v) -> boolean?
  v : any/c
procedure
(skip-list-ref skip-list key [default]) -> any/c
  skip-list : skip-list?
  key : any/c
  default : any/c = (lambda () (error ....))
procedure
(skip-list-set! skip-list key value) -> void?
  skip-list : skip-list?
  key : any/c
  value : any/c
procedure
(skip-list-remove! skip-list key) -> void?
  skip-list : skip-list?
  key : any/c
procedure
(skip-list-count skip-list) -> exact-nonnegative-integer?
  skip-list : skip-list?
procedure
(skip-list-remove-range! skip-list from to) -> void?
  skip-list : skip-list?
  from : any/c
  to : any/c
procedure
(skip-list-contract! skip-list from to) -> void?
  skip-list : adjustable-skip-list?
  from : exact-integer?
  to : exact-integer?
procedure
(skip-list-expand! skip-list from to) -> void?
  skip-list : adjustable-skip-list?
  from : exact-integer?
  to : exact-integer?
procedure
(skip-list-iterate-first skip-list) -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
procedure
(skip-list-iterate-next skip-list iter)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  iter : skip-list-iter?
procedure
(skip-list-iterate-key skip-list iter) -> any/c
  skip-list : skip-list?
  iter : skip-list-iter?
procedure
(skip-list-iterate-value skip-list iter) -> any/c
  skip-list : skip-list?
  iter : skip-list-iter?
procedure
(skip-list-iterate-least/>? skip-list key)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
procedure
(skip-list-iterate-least/>=? skip-list key)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
procedure
(skip-list-iterate-greatest/<? skip-list 
                               key)      
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
procedure
(skip-list-iterate-greatest/<=? skip-list 
                                key)      
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
procedure
(skip-list-iterate-least skip-list) -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
procedure
(skip-list-iterate-greatest skip-list)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
procedure
(skip-list-iter? v) -> boolean?
  v : any/c
procedure
(skip-list-iter-valid? iter) -> boolean?
  iter : skip-list-iter?
procedure
(skip-list->list skip-list) -> (listof pair?)
  skip-list : skip-list?
procedure
(make-interval-map [contents                          
                    #:key-contract key-contract       
                    #:value-contract value-contract]) 
 -> interval-map?
  contents : (listof (cons/c (cons/c exact-integer? exact-integer?) any/c))
           = null
  key-contract : contract? = any/c
  value-contract : contract? = any/c
procedure
(interval-map? v) -> boolean?
  v : any/c
procedure
(interval-map-ref  interval-map     
                   position         
                  [default])    -> any/c
  interval-map : interval-map?
  position : exact-integer?
  default : any/c = (lambda () (error ....))
procedure
(interval-map-ref/bounds  interval-map 
                          position     
                         [default])    
 -> (or/c #f exact-integer?)
    (or/c #f exact-integer?)
    any/c
  interval-map : interval-map?
  position : exact-integer?
  default : any/c = (lambda () (error ....))
procedure
(interval-map-set! interval-map     
                   start            
                   end              
                   value)       -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
  value : any/c
procedure
(interval-map-update*!  interval-map     
                        start            
                        end              
                        updater          
                       [default])    -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
  updater : (-> any/c any/c)
  default : any/c = (lambda () (error ....))
procedure
(interval-map-remove! interval-map     
                      start            
                      end)         -> void?
  interval-map : interval-map?
  start : (or/c exact-integer? -inf.0)
  end : (or/c exact-integer? +inf.0)
procedure
(interval-map-contract! interval-map     
                        start            
                        end)         -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
procedure
(interval-map-expand! interval-map     
                      start            
                      end)         -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
procedure
(interval-map-cons*!  interval-map     
                      start            
                      end              
                      v                
                     [default])    -> void?
  interval-map : interval-map?
  start : any/c
  end : any/c
  v : any/c
  default : any/c = null
procedure
(interval-map-iterate-first interval-map)
 -> (or/c interval-map-iter? #f)
  interval-map : interval-map?
procedure
(interval-map-iterate-next interval-map 
                           iter)        
 -> (or/c interval-map-iter? #f)
  interval-map : interval-map?
  iter : interval-map-iter?
procedure
(interval-map-iterate-key interval-map     
                          iter)        -> pair?
  interval-map : interval-map?
  iter : interval-map-iter?
procedure
(interval-map-iterate-value interval-map     
                            iter)        -> any
  interval-map : interval-map?
  iter : interval-map-iter?
procedure
(interval-map-iter? v) -> boolean?
  v : any/c
procedure
(make-heap <=?) -> heap?
  <=? : (-> any/c any/c any/c)
procedure
(heap? x) -> boolean?
  x : any/c
procedure
(heap-count h) -> exact-nonnegative-integer?
  h : heap?
procedure
(heap-add! h v ...) -> void?
  h : heap?
  v : any/c
procedure
(heap-add-all! h v) -> void?
  h : heap?
  v : (or/c list? vector? heap?)
procedure
(heap-min h) -> any/c
  h : heap?
procedure
(heap-remove-min! h) -> void?
  h : heap?
procedure
(heap-remove! h v [#:same? same?]) -> void?
  h : heap?
  v : any/c
  same? : (-> any/c any/c any/c) = equal?
procedure
(vector->heap <=? items) -> heap?
  <=? : (-> any/c any/c any/c)
  items : vector?
procedure
(heap->vector h) -> vector?
  h : heap?
procedure
(heap-copy h) -> heap?
  h : heap?
procedure
(in-heap/consume! heap) -> sequence?
  heap : heap?
procedure
(in-heap heap) -> sequence?
  heap : heap?
procedure
(heap-sort! v <=?) -> void?
  v : (and/c vector? (not/c immutable?))
  <=? : (-> any/c any/c any/c)
procedure
(make-integer-set wfs) -> integer-set?
  wfs : well-formed-set?
procedure
(integer-set-contents s) -> well-formed-set?
  s : integer-set?
procedure
(set-integer-set-contents! s wfs) -> void?
  s : integer-set?
  wfs : well-formed-set?
procedure
(integer-set? v) -> boolean?
  v : any/c
procedure
(well-formed-set? v) -> boolean?
  v : any/c
procedure
(make-range) -> integer-set?
(make-range elem) -> integer-set?
  elem : exact-integer?
(make-range start end) -> integer-set?
  start : exact-integer?
  end : exact-integer?
procedure
(intersect x y) -> integer-set?
  x : integer-set?
  y : integer-set?
procedure
(subtract x y) -> integer-set?
  x : integer-set?
  y : integer-set?
procedure
(union x y) -> integer-set?
  x : integer-set?
  y : integer-set?
procedure
(split x y) -> integer-set? integer-set? integer-set?
  x : integer-set?
  y : integer-set?
procedure
(complement s start end) -> integer-set?
  s : integer-set?
  start : exact-integer?
  end : exact-integer?
procedure
(symmetric-difference x y) -> integer-set?
  x : integer-set?
  y : integer-set?
procedure
(member? k s) -> boolean?
  k : exact-integer?
  s : integer-set?
procedure
(get-integer set) -> (or/c exact-integer? #f)
  set : integer-set?
procedure
(foldr proc base-v s) -> any/c
  proc : (exact-integer? any/c . -> . any/c)
  base-v : any/c
  s : integer-set?
procedure
(partition s) -> (listof integer-set?)
  s : (listof integer-set?)
procedure
(count s) -> exact-nonnegative-integer?
  s : integer-set?
procedure
(subset? x y) -> boolean?
  x : integer-set?
  y : integer-set?
procedure
(make-bit-vector size [fill]) -> bit-vector?
  size : exact-integer?
  fill : boolean? = #f
procedure
(bit-vector elem ...) -> bit-vector?
  elem : boolean?
procedure
(bit-vector? v) -> boolean?
  v : any/c
procedure
(bit-vector-ref bv index [default]) -> any/c
  bv : bit-vector?
  index : exact-nonnegative-integer?
  default : any/c = (error ....)
procedure
(bit-vector-set! bv index value) -> void?
  bv : bit-vector?
  index : (and/c exact-nonnegative-integer?
                 (</c (+ 1 (bit-vector-length vv))))
  value : boolean?
procedure
(bit-vector-length bv) -> exact-nonnegative-integer?
  bv : bit-vector?
procedure
(bit-vector-popcount bv) -> exact-nonnegative-integer?
  bv : bit-vector?
procedure
(bit-vector-copy bv [start end]) -> bit-vector?
  bv : bit-vector?
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (vector-length v)
procedure
(in-bit-vector bv) -> sequence?
  bv : bit-vector?
syntax
(for/bit-vector maybe-length (for-clause ...)
  body-or-break ... body)
 
maybe-length = 
             | #:length length-expr
             | #:length length-expr #:fill fill-expr
 
  length-expr : exact-nonnegative-integer?
syntax
(for*/bit-vector maybe-length (for-clause ...)
  body-or-break ... body)
procedure
(bit-vector->list bv) -> (listof boolean?)
  bv : bit-vector?
procedure
(list->bit-vector bits) -> bit-vector?
  bits : (listof boolean?)
procedure
(bit-vector->string bv) -> (and/c string? #rx"^[01]*$")
  bv : bit-vector?
procedure
(string->bit-vector s) -> bit-vector?
  s : (and/c string? #rx"^[01]*$")
procedure
(uf-new c) -> uf-set?
  c : any/c
procedure
(uf-set? x) -> boolean?
  x : any/c
procedure
(uf-find a) -> any/c
  a : uf-set?
procedure
(uf-union! a b) -> void?
  a : uf-set?
  b : uf-set?
procedure
(uf-same-set? a b) -> boolean?
  a : uf-set?
  b : uf-set?
procedure
(uf-set-canonical! a c) -> void?
  a : uf-set?
  c : any/c
procedure
(enum? x) -> boolean?
  x : any/c
procedure
(finite-enum? v) -> boolean?
  v : any/c
procedure
(infinite-enum? v) -> boolean?
  v : any/c
procedure
(two-way-enum? v) -> boolean?
  v : any/c
procedure
(one-way-enum? v) -> boolean?
  v : any/c
procedure
(flat-enum? v) -> boolean?
  v : any/c
procedure
(enum-count e) -> natural?
  e : finite-enum?
procedure
(enum-contract e) -> natural?
  e : finite-enum?
procedure
(from-nat e n) -> (enum-contract e)
  e : enum?
  n : (if (finite-enum? e)
          (integer-in 0 (enum-count e))
          natural?)
procedure
(to-nat e x) -> (if (finite-enum? e)
                    (integer-in 0 (enum-count e))
                    natural?)
  e : two-way-enum?
  x : (enum-contract e)
procedure
(enum->list e [n]) -> (listof (enum-contract e))
  e : enum?
  n : (if (finite-enum? e)              = (enum-count e)
          (integer-in 0 (enum-count e))
          natural?)
procedure
(in-enum e) -> sequence?
  e : enum?
value
natural/e : (and/c infinite-enum? two-way-enum? flat-enum?)
procedure
(below/e max) -> (and/c (if (= max +inf.0)
                            finite-enum?
                            infinite-enum?)
                        two-way-enum?
                        flat-enum?)
  max : (or/c natural? +inf.0)
value
empty/e : (and/c finite-enum? two-way-enum? flat-enum?)
procedure
(map/e f f-inv #:contract c e) -> enum?
  f : (-> (enum-contract e) c)
  f-inv : (-> c (enum-contract e))
  c : contract?
  e : enum?
(map/e f f-inv #:contract c e ...+) -> enum?
  f : (dynamic->* #:mandatory-domain-contracts (map enum-contract e)
                  #:range-contracts (list c))
  f-inv : (dynamic->* #:mandatory-domain-contracts (list c)
                      #:range-contracts (map enum-contract e))
  c : contract?
  e : enum?
procedure
(pam/e f #:contract c e ...+) -> one-way-enum?
  f : (dynamic->* #:mandatory-domain-contracts (map enum-contract e)
                  #:range-contracts (list c))
  c : contract?
  e : enum?
procedure
(except/e e [#:contract c] x ...) -> two-way-enum?
  e : two-way-enum?
  c : (or/c #f contract?) = #f
  x : (enum-contract e)
procedure
(or/e [#:one-way-enum? one-way-enum?] e-p ...) -> enum?
  one-way-enum? : boolean? = #f
  e-p : (or/c enum? (cons/c enum? (-> any/c boolean?)))
procedure
(append/e [#:one-way-enum? one-way-enum?]     
           e-p ...+)                      -> enum?
  one-way-enum? : boolean? = #f
  e-p : (or/c enum? (cons/c enum? (-> any/c boolean?)))
procedure
(thunk/e  eth                                  
         [#:count count                        
          #:two-way-enum? is-two-way-enum?     
          #:flat-enum? is-flat-enum?])     -> enum?
  eth : (-> (and/c (if (= count +inf.0)
                       infinite-enum?
                       (and/c finite-enum?
                              (let ([matching-count? (λ (e) (= (enum-count e) count))])
                                matching-count?)))
                   (if is-two-way-enum?
                       two-way-enum?
                       one-way-enum?)
                   (if is-flat-enum?
                       flat-enum?
                       (not/c flat-enum?))))
  count : (or/c +inf.0 natural?) = +inf.0
  is-two-way-enum? : any/c = #t
  is-flat-enum? : any/c = #t
procedure
(list/e [#:ordering ordering] e ...) -> enum?
  ordering : (or/c 'diagonal 'square) = 'square
  e : enum?
procedure
(dep/e  e                                     
        f                                     
       [#:f-range-finite? f-range-finite?     
        #:flat? flat?                         
        #:one-way? one-way?])             -> enum?
  e : enum?
  f : (-> (enum-contract e)
          (and/c (if f-range-finite?
                     finite-enum?
                     infinite-enum?)
                 (if one-way?
                     one-way-enum?
                     two-way-enum?)
                 (if flat?
                     flat-enum?
                     (not/c flat-enum?))))
  f-range-finite? : boolean? = #f
  flat? : boolean? = #t
  one-way? : boolean? = (one-way-enum? e)
procedure
(bounded-list/e k n)
 -> (and/c finite-enum? two-way-enum? flat-enum?)
  k : natural?
  n : natural?
syntax
(cons/de [car-id car-enumeration-expr]
         [cdr-id (car-id) cdr-enumeration-expr]
         cons/de-option)
(cons/de [car-id (cdr-id) car-enumeration-expr]
         [cdr-id cdr-enumeration-expr]
         cons/de-option)
 
cons/de-option = 
               | #:dep-expression-finite? expr cons/de-option
               | #:flat? expr cons/de-option
               | #:one-way? expr cons/de-option
procedure
(flip-dep/e  e                                      
             f                                      
            [#:f-range-finite? f-range-finite?]     
             #:flat? flat?                          
            [#:one-way? one-way?])              -> enum?
  e : enum?
  f : (-> (enum-contract e)
          (and/c (if f-range-finite?
                     finite-enum?
                     infinite-enum?)
                 (if one-way?
                     one-way-enum?
                     two-way-enum?)
                 (if flat?
                     flat-enum?
                     (not/c flat-enum?))))
  f-range-finite? : boolean? = #f
  flat? : #t
  one-way? : boolean? = (one-way-enum? e)
procedure
(cons/e e1 e2 [#:ordering ordering]) -> enum?
  e1 : enum?
  e2 : enum?
  ordering : (or/c 'diagonal 'square) = 'square
procedure
(listof/e  e                                           
          [#:simple-recursive? simple-recursive?]) -> enum?
  e : (if simple-recursive?
          enum?
          infinite-enum?)
  simple-recursive? : any/c = #t
procedure
(non-empty-listof/e  e                                       
                    [#:simple-recursive? simple-recursive?]) 
 -> enum?
  e : (if simple-recursive?
          enum?
          infinite-enum?)
  simple-recursive? : any/c = #t
procedure
(listof-n/e e n) -> enum?
  e : (if simple-recursive?
          enum?
          infinite-enum?)
  n : natural?
syntax
(delay/e enum-expression ... keyword-options)
 
keyword-options = 
                | #:count count-expression keyword-options
                | #:two-way-enum? two-way-boolean-expression keyword-options
                | #:flat-enum? flat-boolean-expression keyword-options
procedure
(take/e e n #:contract contract) -> finite-enum?
  e : enum?
  n : (if (finite-enum? e)
          (integer-in 0 (enum-count e))
          natural?)
  contract : (λ (x)
               (and ((enum-contract e) x)
                    (< (to-nat e x) n)))
procedure
(slice/e e lo hi #:contract contract) -> finite-enum?
  e : enum?
  lo : (and/c (if (finite-enum? e)
                  (integer-in 0 (enum-count e))
                  natural?)
              (<=/c hi))
  hi : (if (finite-enum? e)
           (integer-in 0 (enum-count e))
           natural?)
  contract : (and/c (enum-contract e)
                    (λ (x)
                      (<= lo (to-nat e x))
                      (< (to-nat e x) hi)))
procedure
(fin/e x ...) -> (and/c finite-enum? flat-enum?)
  x : any/c
procedure
(single/e v #:equal? same?) -> (and/c finite-enum? two-way-enum?)
  v : any/c
  same? : equal?
procedure
(range/e lo hi) -> (and/c two-way-enum? flat-enum?)
  lo : (and/c (or/c -inf.0 exact-integer?)
              (<=/c hi))
  hi : (or/c exact-integer? +inf.0)
procedure
(nat+/e lo) -> (and/c infinite-enum? two-way-enum? flat-enum?)
  lo : natural?
procedure
(vector/e [#:ordering ordering] e ...) -> enum?
  ordering : (or/c 'diagonal 'square) = 'square
  e : enum?
procedure
(permutations-of-n/e n)
 -> (and/c finite-enum? two-way-enum? flat-enum?)
  n : natural?
procedure
(permutations/e l) -> enum?
  l : list?
procedure
(set/e e) -> enum?
  e : enum?
procedure
(infinite-sequence/e e) -> one-way-enum?
  e : finite-enum?
procedure
(hash-traverse/e f                               
                 xs                              
                 #:get-contract get-contract     
                 #:contract contract)        -> enum?
  f : (-> any/c enum?)
  xs : (hash/c any/c any/c)
  get-contract : (-> any/c contract?)
  contract : contract?
procedure
(fold-enum f                                      
           bs                                     
           #:f-range-finite? f-range-finite?) -> enum?
  f : (if f-range-finite?
          (-> list? any/c finite-enum?)
          (-> list? any/c infinite-enum?))
  bs : list?
  f-range-finite? : #f
procedure
(random-index e) -> natural?
  e : enum?
value
char/e : (and/c finite-enum? two-way-enum? flat-enum?)
value
string/e : (and/c infinite-enum? two-way-enum? flat-enum?)
value
bool/e : (and/c finite-enum? two-way-enum? flat-enum?)
value
symbol/e : (and/c infinite-enum? two-way-enum? flat-enum?)
value
integer/e : (and/c infinite-enum? two-way-enum? flat-enum?)
value
flonum/e : (and/c infinite-enum? two-way-enum? flat-enum?)
value
exact-rational/e
 : (and/c infinite-enum? one-way-enum? flat-enum?)
value
two-way-real/e : (and/c infinite-enum? two-way-enum? flat-enum?)
value
real/e : (and/c infinite-enum? one-way-enum? flat-enum?)
value
two-way-number/e
 : (and/c infinite-enum? two-way-enum? flat-enum?)
value
number/e : (and/c infinite-enum? one-way-enum? flat-enum?)
