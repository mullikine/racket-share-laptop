23412
((3) 0 () 11 ((q lib "typed-racket/base-env/base-types.rkt") (q lib "typed-racket/base-env/base-types-extra.rkt") (q lib "typed-racket/base-env/prims.rkt") (q lib "typed-racket/typed-racket.rkt") (q lib "typed/racket/class.rkt") (q lib "typed/racket/unit.rkt") (q lib "typed-racket/base-env/extra-procs.rkt") (q lib "typed/racket/unsafe.rkt") (q lib "typed/scheme/base.rkt") (q lib "typed/untyped-utils.rkt") (q lib "typed/racket/base.rkt")) () (h ! (equal) ((c form c (c (? . 0) q BoxTop)) q (3415 . 2)) ((c form c (c (? . 3) q #%top-interaction)) q (14401 . 2)) ((c form c (c (? . 1) q Un)) q (26052 . 2)) ((c form c (c (? . 2) q for*/extflvector:)) q (25314 . 2)) ((c form c (c (? . 0) q Single-Flonum-Complex)) q (230 . 2)) ((c form c (c (? . 1) q Values)) q (6452 . 2)) ((c form c (c (? . 0) q Void)) q (2175 . 2)) ((c form c (c (? . 2) q for:)) q (25244 . 2)) ((c form c (c (? . 2) q for/and)) q (9876 . 2)) ((c form c (c (? . 0) q Semaphore)) q (3069 . 2)) ((c form c (c (? . 1) q Struct)) q (6533 . 2)) ((c form c (c (? . 0) q ChannelTop)) q (3778 . 2)) ((c form c (c (? . 2) q plet:)) q (24538 . 2)) ((c form c (c (? . 2) q for*/hasheq)) q (9404 . 2)) ((c form c (c (? . 0) q Number)) q (43 . 2)) ((c form c (c (? . 0) q Nonnegative-Inexact-Real)) q (1210 . 2)) ((c form c (c (? . 2) q do:)) q (25865 . 2)) ((c form c (c (? . 2) q let-values)) q (7192 . 2)) ((c form c (c (? . 2) q let:)) q (24446 . 3)) ((c def c (c (? . 6) q assert)) q (22226 . 6)) ((c form c (c (? . 2) q pdefine:)) q (26019 . 2)) ((c form c (c (? . 3) q SSL-Client-Context)) q (14670 . 2)) ((c form c (c (? . 1) q Top)) q (6267 . 2)) ((c form c (c (? . 2) q for*/hash:)) q (25357 . 2)) ((c form c (c (? . 0) q Namespace)) q (2357 . 2)) ((c form c (c (? . 0) q Float-Zero)) q (862 . 2)) ((c form c (c (? . 2) q for/vector:)) q (25846 . 2)) ((c form c (c (? . 3) q IMAP-Connection)) q (14535 . 2)) ((c form c (c (? . 2) q for/or)) q (9009 . 2)) ((c form c (c (? . 0) q Exact-Number)) q (189 . 2)) ((c form c (c (? . 2) q define)) q (10905 . 30)) ((c form c (c (? . 2) q define-typed-struct)) q (25901 . 2)) ((c form c (c (? . 0) q PRegexp)) q (2290 . 2)) ((c form c (c (? . 0) q TCP-Listener)) q (2912 . 2)) ((c form c (c (? . 1) q Struct-Type)) q (6553 . 2)) ((c form c (c (? . 2) q for*/and)) q (10071 . 2)) ((c form c (c (? . 0) q Pairof)) q (3204 . 2)) ((c form c (c (? . 2) q for/hash)) q (8742 . 2)) ((c form c (c (? . 0) q Path-String)) q (3185 . 2)) ((c form c (c (? . 0) q Inexact-Complex)) q (259 . 2)) ((c form c (c (? . 3) q JSExpr)) q (14470 . 2)) ((c form c (c (? . 4) q class)) q (15082 . 45)) ((c form c (c (? . 3) q with-type)) q (23255 . 10)) ((c form c (c (? . 1) q Instance)) q (18619 . 2)) ((c form c (c (? . 3) q SSL-Verify-Source)) q (14729 . 2)) ((c form c (c (? . 2) q letrec-values)) q (7249 . 2)) ((c form c (c (? . 0) q Pretty-Print-Style-Table)) q (2661 . 2)) ((c form c (c (? . 4) q define/augment)) q (17284 . 3)) ((c form c (c (? . 0) q Negative-Inexact-Real)) q (1242 . 2)) ((c form c (c (? . 2) q for/set)) q (9208 . 2)) ((c form c (c (? . 2) q lambda)) q (7433 . 26)) ((c form c (c (? . 0) q Nonpositive-Inexact-Real)) q (1271 . 2)) ((c form c (c (? . 2) q define-new-subtype)) q (26705 . 2)) ((c form c (c (? . 3) q SSL-Protocol)) q (14628 . 2)) ((c form c (c (? . 1) q List)) q (3245 . 2)) ((c form c (c (? . 0) q Sexpof)) q (4185 . 2)) ((c form c (c (? . 0) q Nonpositive-Float)) q (701 . 2)) ((c form c (c (? . 0) q Flonum-Positive-Zero)) q (834 . 2)) ((c form c (c (? . 7) q unsafe-require/typed)) q (23549 . 2)) ((c form c (c (? . 0) q Fixnum)) q (1736 . 2)) ((c form c (c (? . 1) q AnyValues)) q (11 . 2)) ((c form c (c (? . 0) q Regexp)) q (2276 . 2)) ((c form c (c (? . 2) q struct:)) q (25180 . 2)) ((c form c (c (? . 2) q define-struct:)) q (25195 . 2)) ((c form c (c (? . 2) q with-handlers)) q (14253 . 2)) ((c form c (c (? . 2) q define-struct)) q (12335 . 12)) ((c form c (c (? . 0) q Compiled-Expression)) q (2599 . 2)) ((c form c (c (? . 0) q Natural)) q (482 . 2)) ((c form c (c (? . 2) q let/ec:)) q (24897 . 2)) ((c form c (c (? . 5) q define-values/invoke-unit/infer)) q (20911 . 8)) ((c form c (c (? . 0) q Path-For-Some-System)) q (2248 . 2)) ((c form c (c (? . 2) q for/sum:)) q (25830 . 2)) ((c form c (c (? . 0) q Single-Flonum)) q (114 . 2)) ((c form c (c (? . 5) q unit)) q (18873 . 16)) ((c form c (c (? . 2) q opt-lambda:)) q (23978 . 6)) ((c form c (c (? . 1) q List*)) q (3308 . 2)) ((c form c (c (? . 4) q inherit-field)) q (17542 . 2)) ((c form c (c (? . 2) q require/opaque-type)) q (25928 . 2)) ((c form c (c (? . 2) q for*/and:)) q (25256 . 2)) ((c form c (c (? . 1) q Prefab)) q (6600 . 2)) ((c form c (c (? . 0) q Syntax-E)) q (4169 . 2)) ((c form c (c (? . 3) q Cursor)) q (15050 . 2)) ((c form c (c (? . 2) q for*/list)) q (9272 . 2)) ((c form c (c (? . 2) q for/sum)) q (9076 . 2)) ((c form c (c (? . 0) q ExtFlonum)) q (1848 . 2)) ((c form c (c (? . 0) q Flonum-Negative-Zero)) q (779 . 2)) ((c form c (c (? . 2) q for/lists)) q (10269 . 4)) ((c form c (c (? . 2) q ann)) q (13242 . 2)) ((c form c (c (? . 1) q Sequenceof)) q (3933 . 2)) ((c form c (c (? . 3) q for*/extflvector)) q (14824 . 2)) ((c form c (c (? . 2) q for/first)) q (9940 . 2)) ((c form c (c (? . 2) q let/cc)) q (7367 . 2)) ((c form c (c (? . 0) q String)) q (2120 . 2)) ((c form c (c (? . 2) q for*/hasheqv:)) q (25395 . 2)) ((c form c (c (? . 0) q ExtFlonum-Zero)) q (2037 . 2)) ((c form c (c (? . 2) q for*)) q (10463 . 3)) ((c form c (c (? . 0) q Parameterization)) q (2814 . 2)) ((c form c (c (? . 2) q for/lists:)) q (25761 . 2)) ((c form c (c (? . 3) q HTTP-Connection)) q (14514 . 2)) ((c form c (c (? . 4) q define/pubment)) q (17204 . 3)) ((c form c (c (? . 0) q Float-Complex)) q (209 . 2)) ((c form c (c (? . 1) q caseâ†’)) q (6713 . 2)) ((c form c (c (? . 0) q VectorTop)) q (3525 . 2)) ((c form c (c (? . 0) q Identifier)) q (4137 . 2)) ((c form c (c (? . 0) q Struct-Type-Property)) q (2716 . 2)) ((c form c (c (? . 0) q Symbol)) q (2149 . 2)) ((c form c (c (? . 0) q Nonpositive-Real)) q (1616 . 2)) ((c form c (c (? . 0) q Async-ChannelTop)) q (3824 . 2)) ((c form c (c (? . 1) q All)) q (6399 . 3)) ((c form c (c (? . 2) q popt-lambda:)) q (24216 . 3)) ((c form c (c (? . 0) q Continuation-Mark-Keyof)) q (4278 . 2)) ((c form c (c (? . 2) q for*/last)) q (10203 . 2)) ((c form c (c (? . 0) q UDP-Socket)) q (2894 . 2)) ((c form c (c (? . 0) q Weak-HashTable)) q (3610 . 2)) ((c form c (c (? . 0) q Channelof)) q (3756 . 2)) ((c form c (c (? . 2) q for*/or)) q (9609 . 2)) ((c form c (c (? . 0) q Complex)) q (57 . 2)) ((c form c (c (? . 0) q Nonnegative-Exact-Rational)) q (1451 . 2)) ((c form c (c (? . 0) q Positive-Byte)) q (1680 . 2)) ((c def c (c (? . 6) q defined?)) q (22445 . 3)) ((c form c (c (? . 2) q for*/set)) q (9811 . 2)) ((c form c (c (? . 0) q Vectorof)) q (3429 . 2)) ((c form c (c (? . 2) q case-lambda:)) q (24315 . 2)) ((c form c (c (? . 3) q Time)) q (15062 . 2)) ((c form c (c (? . 0) q Inexact-Real-Positive-Zero)) q (1337 . 2)) ((c form c (c (? . 0) q Weak-Boxof)) q (4032 . 2)) ((c form c (c (? . 0) q Continuation-Mark-Set)) q (2447 . 2)) ((c form c (c (? . 0) q Real-Zero)) q (1640 . 2)) ((c form c (c (? . 0) q Nonpositive-Fixnum)) q (1822 . 2)) ((c form c (c (? . 0) q Internal-Definition-Context)) q (2626 . 2)) ((c form c (c (? . 3) q for*/flvector)) q (14966 . 2)) ((c form c (c (? . 0) q Variable-Reference)) q (2398 . 2)) ((c form c (c (? . 0) q Option)) q (6739 . 2)) ((c form c (c (? . 0) q Resolved-Module-Path)) q (2537 . 2)) ((c form c (c (? . 3) q GIF-Colormap)) q (14452 . 2)) ((c form c (c (? . 2) q for/vector)) q (8942 . 2)) ((c form c (c (? . 0) q HashTable)) q (3640 . 2)) ((c form c (c (? . 4) q inherit)) q (17809 . 2)) ((c form c (c (? . 0) q Inspector)) q (2855 . 2)) ((c form c (c (? . 10) q values)) q (26114 . 2)) ((c form c (c (? . 2) q let*-values)) q (7309 . 2)) ((c form c (c (? . 0) q Nonpositive-ExtFlonum)) q (1946 . 2)) ((c form c (c (? . 2) q for*/last:)) q (25416 . 2)) ((c form c (c (? . 0) q Negative-Real)) q (1595 . 2)) ((c form c (c (? . 2) q case-lambda)) q (8253 . 2)) ((c form c (c (? . 0) q Impersonator-Property)) q (2744 . 2)) ((c form c (c (? . 2) q :)) q (13163 . 3)) ((c form c (c (? . 2) q row-inst)) q (13358 . 2)) ((c form c (c (? . 1) q Tuple)) q (26072 . 2)) ((c form c (c (? . 0) q Immutable-HashTable)) q (3542 . 2)) ((c form c (c (? . 7) q unsafe-provide)) q (23598 . 2)) ((c form c (c (? . 2) q letrec)) q (7114 . 2)) ((c form c (c (? . 0) q MListof)) q (3338 . 2)) ((c form c (c (? . 0) q Flonum-Zero)) q (880 . 2)) ((c form c (c (? . 0) q Syntaxof)) q (4116 . 2)) ((c form c (c (? . 0) q Float-Nan)) q (899 . 2)) ((c form c (c (? . 3) q for/flvector)) q (14897 . 2)) ((c form c (c (? . 2) q for/list)) q (8677 . 2)) ((c form c (c (? . 0) q Nonpositive-Flonum)) q (726 . 2)) ((c form c (c (? . 1) q Parameter)) q (26085 . 2)) ((c form c (c (? . 0) q Read-Table)) q (2773 . 2)) ((c form c (c (? . 2) q define-type-alias)) q (25876 . 2)) ((c form c (c (? . 1) q ->*)) q (5869 . 15)) ((c form c (c (? . 1) q Object)) q (18494 . 5)) ((c form c (c (? . 0) q False)) q (2107 . 2)) ((c form c (c (? . 2) q for/product:)) q (25810 . 2)) ((c form c (c (? . 4) q define/public)) q (17044 . 3)) ((c form c (c (? . 0) q ExtFlonum-Negative-Zero)) q (1975 . 2)) ((c form c (c (? . 0) q Positive-Flonum)) q (582 . 2)) ((c form c (c (? . 2) q for*/first)) q (10136 . 2)) ((c form c (c (? . 0) q Byte-PRegexp)) q (2324 . 2)) ((c form c (c (? . 0) q Positive-Single-Flonum)) q (934 . 2)) ((c form c (c (? . 5) q define-values/invoke-unit)) q (19417 . 8)) ((c form c (c (? . 0) q Thread-Group)) q (2997 . 2)) ((c form c (c (? . 0) q Float-Negative-Zero)) q (752 . 2)) ((c form c (c (? . 2) q with-asserts)) q (22341 . 5)) ((c form c (c (? . 2) q for*/product:)) q (25504 . 2)) ((c form c (c (? . 0) q Setof)) q (3738 . 2)) ((c form c (c (? . 0) q Inexact-Real-Negative-Zero)) q (1303 . 2)) ((c form c (c (? . 2) q for*/sum:)) q (25525 . 2)) ((c form c (c (? . 0) q Output-Port)) q (2205 . 2)) ((c form c (c (? . 0) q Single-Flonum-Positive-Zero)) q (1095 . 2)) ((c form c (c (? . 2) q let-values:)) q (24682 . 2)) ((c form c (c (? . 0) q Ephemeronof)) q (4074 . 2)) ((c form c (c (? . 0) q Nothing)) q (28 . 2)) ((c form c (c (? . 3) q PortT/Bytes)) q (14611 . 2)) ((c form c (c (? . 2) q let*-values:)) q (24803 . 2)) ((c form c (c (? . 2) q for*/lists:)) q (25452 . 2)) ((c form c (c (? . 2) q let/cc:)) q (24863 . 2)) ((c form c (c (? . 0) q Continuation-Mark-KeyTop)) q (4314 . 2)) ((c form c (c (? . 2) q do)) q (10723 . 7)) ((c form c (c (? . 0) q Special-Comment)) q (2693 . 2)) ((c form c (c (? . 2) q declare-refinement)) q (26603 . 2)) ((c form c (c (? . 3) q GIF-Stream)) q (14436 . 2)) ((c form c (c (? . 9) q define-typed/untyped-identifier)) q (22949 . 2)) ((c form c (c (? . 5) q define-compound-unit/infer)) q (20662 . 5)) ((c form c (c (? . 2) q for*/fold:)) q (25339 . 2)) ((c form c (c (? . 2) q let*)) q (7154 . 2)) ((c form c (c (? . 0) q Exact-Complex)) q (299 . 2)) ((c form c (c (? . 2) q :query-type/args)) q (23184 . 2)) ((c form c (c (? . 0) q Zero)) q (548 . 2)) ((c form c (c (? . 0) q Struct-TypeTop)) q (6578 . 2)) ((c form c (c (? . 0) q ExtFlonum-Nan)) q (2059 . 2)) ((c def c (c (? . 2) q default-continuation-prompt-tag)) q (14274 . 3)) ((c form c (c (? . 2) q for/flvector:)) q (25609 . 2)) ((c form c (c (? . 3) q Cookie)) q (14482 . 2)) ((c form c (c (? . 8) q require/typed)) q (26128 . 12)) ((c form c (c (? . 2) q for*/hash)) q (9338 . 2)) ((c form c (c (? . 0) q Futureof)) q (3912 . 2)) ((c form c (c (? . 0) q Place)) q (3035 . 2)) ((c form c (c (? . 8) q require-typed-struct)) q (26575 . 2)) ((c form c (c (? . 0) q Datum)) q (4216 . 2)) ((c form c (c (? . 2) q inst)) q (13300 . 3)) ((c form c (c (? . 1) q U)) q (6306 . 2)) ((c form c (c (? . 0) q Custodian)) q (2838 . 2)) ((c form c (c (? . 0) q Negative-Integer)) q (497 . 2)) ((c form c (c (? . 2) q define-typed-struct/exec)) q (26659 . 2)) ((c form c (c (? . 4) q private)) q (17778 . 2)) ((c form c (c (? . 0) q Negative-Fixnum)) q (1799 . 2)) ((c form c (c (? . 2) q define-struct/exec)) q (12694 . 8)) ((c form c (c (? . 2) q define-predicate)) q (13128 . 2)) ((c form c (c (? . 0) q Path)) q (2236 . 2)) ((c form c (c (? . 2) q assert-typecheck-fail)) q (22716 . 3)) ((c form c (c (? . 4) q pubment)) q (17651 . 2)) ((c form c (c (? . 0) q Positive-Real)) q (1550 . 2)) ((c form c (c (? . 0) q Keyword)) q (2134 . 2)) ((c form c (c (? . 0) q Pseudo-Random-Generator)) q (3125 . 2)) ((c form c (c (? . 0) q Weak-BoxTop)) q (4055 . 2)) ((c form c (c (? . 2) q require-typed-struct)) q (25955 . 2)) ((c form c (c (? . 2) q for)) q (8309 . 14)) ((c form c (c (? . 0) q Nonpositive-Integer)) q (521 . 2)) ((c form c (c (? . 0) q Namespace-Anchor)) q (2374 . 2)) ((c form c (c (? . 3) q URL)) q (14572 . 2)) ((c form c (c (? . 2) q for*/set:)) q (25471 . 2)) ((c form c (c (? . 0) q Positive-Inexact-Real)) q (1181 . 2)) ((c form c (c (? . 2) q struct)) q (11835 . 15)) ((c form c (c (? . 2) q for/hash:)) q (25671 . 2)) ((c form c (c (? . 1) q Union)) q (6669 . 2)) ((c form c (c (? . 0) q Char)) q (2163 . 2)) ((c form c (c (? . 0) q Security-Guard)) q (2872 . 2)) ((c form c (c (? . 2) q for*/vector:)) q (25542 . 2)) ((c form c (c (? . 0) q Thread-CellTop)) q (4010 . 2)) ((c form c (c (? . 0) q Negative-Float)) q (656 . 2)) ((c form c (c (? . 1) q Bot)) q (6278 . 2)) ((c form c (c (? . 5) q define-signature)) q (18691 . 8)) ((c form c (c (? . 0) q Negative-ExtFlonum)) q (1920 . 2)) ((c form c (c (? . 2) q plambda:)) q (23887 . 3)) ((c form c (c (? . 0) q Environment-Variables)) q (3156 . 2)) ((c form c (c (? . 0) q Will-Executor)) q (3104 . 2)) ((c def c (c (? . 2) q index?)) q (22499 . 3)) ((c form c (c (? . 2) q :type)) q (23076 . 5)) ((c form c (c (? . 1) q !)) q (27873 . 2)) ((c form c (c (? . 2) q :print-type)) q (23160 . 2)) ((c form c (c (? . 2) q letrec-values:)) q (24741 . 2)) ((c form c (c (? . 2) q for*/lists)) q (10527 . 4)) ((c form c (c (? . 2) q for/hasheq)) q (8807 . 2)) ((c form c (c (? . 0) q HashTableTop)) q (3665 . 2)) ((c form c (c (? . 5) q define-unit)) q (19894 . 7)) ((c form c (c (? . 0) q Syntax)) q (4155 . 2)) ((c form c (c (? . 4) q define/private)) q (17364 . 3)) ((c form c (c (? . 4) q init-rest)) q (17582 . 2)) ((c form c (c (? . 2) q for*/hasheq:)) q (25375 . 2)) ((c form c (c (? . 0) q Nonpositive-Single-Flonum)) q (1027 . 2)) ((c form c (c (? . 3) q Date)) q (15072 . 2)) ((c form c (c (? . 0) q Weak-HashTableTop)) q (3713 . 2)) ((c form c (c (? . 4) q define/override)) q (17122 . 3)) ((c form c (c (? . 1) q Intersection)) q (6682 . 2)) ((c form c (c (? . 2) q :query-type/result)) q (23221 . 2)) ((c form c (c (? . 0) q Bytes)) q (2344 . 2)) ((c form c (c (? . 0) q Exact-Imaginary)) q (320 . 2)) ((c form c (c (? . 0) q Place-Channel)) q (3048 . 2)) ((c form c (c (? . 0) q ExtFlonum-Positive-Zero)) q (2006 . 2)) ((c form c (c (? . 0) q FlVector)) q (3474 . 2)) ((c form c (c (? . 0) q Float)) q (87 . 2)) ((c form c (c (? . 0) q Sexp)) q (4204 . 2)) ((c form c (c (? . 3) q Char-Set)) q (15036 . 2)) ((c form c (c (? . 0) q Negative-Flonum)) q (678 . 2)) ((c form c (c (? . 0) q Bytes-Converter)) q (2791 . 2)) ((c form c (c (? . 2) q Î»:)) q (23857 . 2)) ((c form c (c (? . 2) q for*/hasheqv)) q (9472 . 2)) ((c form c (c (? . 2) q define-struct/exec:)) q (25217 . 2)) ((c form c (c (? . 2) q pcase-lambda:)) q (24335 . 3)) ((c form c (c (? . 1) q âˆ©)) q (6325 . 2)) ((c form c (c (? . 0) q Single-Flonum-Negative-Zero)) q (1060 . 2)) ((c form c (c (? . 4) q public)) q (17610 . 2)) ((c form c (c (? . 1) q Refinement)) q (26635 . 2)) ((c form c (c (? . 0) q MPairTop)) q (3381 . 2)) ((c form c (c (? . 1) q case->)) q (6346 . 2)) ((c form c (c (? . 0) q Positive-Index)) q (1714 . 2)) ((c form c (c (? . 2) q for*:)) q (25562 . 2)) ((c form c (c (? . 0) q Boolean)) q (2080 . 2)) ((c form c (c (? . 2) q for/extflvector:)) q (25630 . 2)) ((c form c (c (? . 0) q Inexact-Real)) q (135 . 2)) ((c form c (c (? . 2) q for/hasheq:)) q (25688 . 2)) ((c form c (c (? . 0) q FxVector)) q (3509 . 2)) ((c form c (c (? . 2) q for/hasheqv)) q (8874 . 2)) ((c form c (c (? . 0) q Compiled-Module-Expression)) q (2565 . 2)) ((c form c (c (? . 0) q ExtFlVector)) q (3490 . 2)) ((c form c (c (? . 2) q for/set:)) q (25779 . 2)) ((c form c (c (? . 0) q Pair)) q (26102 . 2)) ((c form c (c (? . 2) q for/fold)) q (10360 . 4)) ((c form c (c (? . 2) q for*/first:)) q (25273 . 2)) ((c form c (c (? . 5) q invoke-unit/infer)) q (20807 . 5)) ((c form c (c (? . 0) q One)) q (1657 . 2)) ((c form c (c (? . 0) q Positive-ExtFlonum)) q (1865 . 2)) ((c form c (c (? . 2) q for/list:)) q (25744 . 2)) ((c form c (c (? . 1) q Class)) q (17851 . 17)) ((c form c (c (? . 2) q for/last:)) q (25727 . 2)) ((c form c (c (? . 1) q Unit)) q (21222 . 13)) ((c form c (c (? . 3) q SSL-Context)) q (14694 . 2)) ((c form c (c (? . 0) q Thread-Cellof)) q (3984 . 2)) ((c form c (c (? . 1) q Rec)) q (6514 . 2)) ((c def c (c (? . 9) q syntax-local-typed-context?)) q (23022 . 2)) ((c form c (c (? . 0) q Port)) q (2224 . 2)) ((c form c (c (? . 0) q Prompt-Tagof)) q (4229 . 2)) ((c form c (c (? . 0) q Undefined)) q (2476 . 2)) ((c form c (c (? . 4) q init-field)) q (17474 . 2)) ((c form c (c (? . 2) q let/ec)) q (7400 . 2)) ((c form c (c (? . 2) q for*/sum)) q (9677 . 2)) ((c form c (c (? . 0) q Logger)) q (2932 . 2)) ((c form c (c (? . 0) q Inexact-Real-Nan)) q (1396 . 2)) ((c form c (c (? . 0) q Positive-Fixnum)) q (1750 . 2)) ((c form c (c (? . 0) q Promise)) q (3892 . 2)) ((c form c (c (? . 0) q Procedure)) q (6289 . 2)) ((c form c (c (? . 0) q Async-Channelof)) q (3796 . 2)) ((c form c (c (? . 0) q Byte)) q (1668 . 2)) ((c form c (c (? . 2) q Î»)) q (8224 . 2)) ((c form c (c (? . 1) q Opaque)) q (6758 . 2)) ((c form c (c (? . 2) q make-predicate)) q (13101 . 2)) ((c form c (c (? . 0) q Module-Path-Index)) q (2512 . 2)) ((c form c (c (? . 4) q override)) q (17693 . 2)) ((c form c (c (? . 0) q Module-Path)) q (2493 . 2)) ((c form c (c (? . 2) q let)) q (6777 . 13)) ((c form c (c (? . 5) q compound-unit/infer)) q (20037 . 15)) ((c form c (c (? . 5) q define-unit-from-context)) q (21174 . 2)) ((c form c (c (? . 0) q Positive-Float)) q (560 . 2)) ((c form c (c (? . 0) q Single-Flonum-Zero)) q (1130 . 2)) ((c form c (c (? . 0) q Exact-Positive-Integer)) q (392 . 2)) ((c form c (c (? . 0) q Inexact-Real-Zero)) q (1371 . 2)) ((c form c (c (? . 2) q provide:)) q (13193 . 2)) ((c form c (c (? . 0) q Real)) q (177 . 2)) ((c form c (c (? . 2) q for*/product)) q (9742 . 2)) ((c form c (c (? . 10) q define-type)) q (12940 . 6)) ((c form c (c (? . 2) q for/or:)) q (25795 . 2)) ((c form c (c (? . 2) q for/fold:)) q (25654 . 2)) ((c form c (c (? . 1) q âˆ€)) q (6728 . 2)) ((c form c (c (? . 2) q for*/vector)) q (9541 . 2)) ((c form c (c (? . 0) q Negative-Exact-Rational)) q (1485 . 2)) ((c form c (c (? . 0) q Boxof)) q (3397 . 2)) ((c form c (c (? . 0) q Exact-Nonnegative-Integer)) q (449 . 2)) ((c form c (c (? . 2) q cast)) q (13280 . 2)) ((c form c (c (? . 0) q Single-Flonum-Nan)) q (1156 . 2)) ((c form c (c (? . 1) q Refine)) q (26757 . 32)) ((c form c (c (? . 2) q for*/list:)) q (25434 . 2)) ((c form c (c (? . 2) q typecheck-fail)) q (22551 . 8)) ((c form c (c (? . 0) q True)) q (2095 . 2)) ((c form c (c (? . 0) q Nonnegative-Single-Flonum)) q (964 . 2)) ((c form c (c (? . 0) q Index)) q (1701 . 2)) ((c form c (c (? . 5) q define-compound-unit)) q (20539 . 5)) ((c form c (c (? . 3) q SSL-Listener)) q (14711 . 2)) ((c form c (c (? . 0) q Exact-Rational)) q (155 . 2)) ((c form c (c (? . 1) q mu)) q (26062 . 2)) ((c form c (c (? . 0) q Custodian-Boxof)) q (3956 . 2)) ((c form c (c (? . 2) q for*/fold)) q (10619 . 4)) ((c form c (c (? . 5) q compound-unit)) q (19655 . 9)) ((c form c (c (? . 5) q unit-from-context)) q (21137 . 2)) ((c form c (c (? . 2) q require/typed/provide)) q (14203 . 2)) ((c form c (c (? . 1) q Parameterof)) q (3848 . 3)) ((c form c (c (? . 0) q Input-Port)) q (2187 . 2)) ((c form c (c (? . 2) q letrec:)) q (24592 . 2)) ((c form c (c (? . 0) q Float-Positive-Zero)) q (807 . 2)) ((c form c (c (? . 0) q Nonnegative-ExtFlonum)) q (1891 . 2)) ((c form c (c (? . 0) q UnitTop)) q (21607 . 2)) ((c form c (c (? . 2) q require-typed-struct/provide)) q (25983 . 2)) ((c form c (c (? . 0) q Nonnegative-Integer)) q (422 . 2)) ((c form c (c (? . 0) q ClassTop)) q (18478 . 2)) ((c form c (c (? . 0) q Nonpositive-Exact-Rational)) q (1516 . 2)) ((c form c (c (? . 1) q pred)) q (26035 . 2)) ((c form c (c (? . 3) q PortT)) q (14600 . 2)) ((c form c (c (? . 0) q Positive-Integer)) q (368 . 2)) ((c form c (c (? . 0) q Imaginary)) q (282 . 2)) ((c form c (c (? . 7) q unsafe-require/typed/provide)) q (23641 . 2)) ((c form c (c (? . 0) q Nonnegative-Real)) q (1571 . 2)) ((c form c (c (? . 1) q ->)) q (4346 . 49)) ((c form c (c (? . 0) q Mutable-HashTableTop)) q (3685 . 2)) ((c form c (c (? . 0) q Nonnegative-Fixnum)) q (1773 . 2)) ((c form c (c (? . 9) q require/untyped-contract)) q (22816 . 5)) ((c form c (c (? . 0) q Flonum-Nan)) q (916 . 2)) ((c form c (c (? . 0) q MPairof)) q (3358 . 2)) ((c form c (c (? . 2) q for*/or:)) q (25488 . 2)) ((c form c (c (? . 2) q for/hasheqv:)) q (25707 . 2)) ((c form c (c (? . 1) q PrefabTop)) q (6632 . 2)) ((c form c (c (? . 0) q FSemaphore)) q (3086 . 2)) ((c form c (c (? . 2) q for/product)) q (9140 . 2)) ((c form c (c (? . 3) q #%module-begin)) q (14366 . 2)) ((c form c (c (? . 0) q Nonnegative-Float)) q (605 . 2)) ((c form c (c (? . 3) q FTP-Connection)) q (14494 . 2)) ((c form c (c (? . 0) q Flonum)) q (100 . 2)) ((c form c (c (? . 2) q for/last)) q (10006 . 2)) ((c form c (c (? . 2) q for*/flvector:)) q (25292 . 2)) ((c form c (c (? . 3) q for/extflvector)) q (14752 . 2)) ((c form c (c (? . 2) q for/and:)) q (25575 . 2)) ((c form c (c (? . 4) q augment)) q (17736 . 2)) ((c form c (c (? . 3) q SSL-Server-Context)) q (14646 . 2)) ((c form c (c (? . 3) q Path/Param)) q (14556 . 2)) ((c form c (c (? . 2) q define:)) q (24931 . 7)) ((c form c (c (? . 0) q Negative-Single-Flonum)) q (997 . 2)) ((c form c (c (? . 0) q Thread)) q (2983 . 2)) ((c form c (c (? . 3) q URL-Exception)) q (14581 . 2)) ((c form c (c (? . 0) q Null)) q (2424 . 2)) ((c form c (c (? . 0) q Evtof)) q (4098 . 2)) ((c form c (c (? . 0) q EOF)) q (2436 . 2)) ((c form c (c (? . 0) q Positive-Exact-Rational)) q (1420 . 2)) ((c form c (c (? . 0) q Subprocess)) q (3017 . 2)) ((c form c (c (? . 0) q Nonnegative-Flonum)) q (630 . 2)) ((c form c (c (? . 4) q field)) q (17510 . 2)) ((c form c (c (? . 0) q Inexact-Imaginary)) q (343 . 2)) ((c form c (c (? . 0) q Integer)) q (72 . 2)) ((c form c (c (? . 2) q let*:)) q (24638 . 2)) ((c form c (c (? . 1) q Row)) q (18654 . 2)) ((c form c (c (? . 2) q lambda:)) q (23698 . 6)) ((c form c (c (? . 0) q Log-Receiver)) q (2946 . 2)) ((c form c (c (? . 0) q Mutable-HashTable)) q (3577 . 2)) ((c form c (c (? . 2) q require/typed)) q (13445 . 20)) ((c form c (c (? . 2) q for/first:)) q (25591 . 2)) ((c form c (c (? . 0) q Any)) q (0 . 2)) ((c form c (c (? . 4) q init)) q (17444 . 2)) ((c form c (c (? . 0) q Log-Level)) q (2966 . 2)) ((c form c (c (? . 0) q Prompt-TagTop)) q (4257 . 2)) ((c form c (c (? . 0) q Byte-Regexp)) q (2305 . 2)) ((c form c (c (? . 5) q invoke-unit)) q (19335 . 3)) ((c form c (c (? . 1) q Vector)) q (3450 . 2)) ((c form c (c (? . 1) q â†’)) q (6702 . 2)) ((c form c (c (? . 0) q Listof)) q (3226 . 2))))
syntax
Any
syntax
AnyValues
syntax
Nothing
syntax
Number
syntax
Complex
syntax
Integer
syntax
Float
syntax
Flonum
syntax
Single-Flonum
syntax
Inexact-Real
syntax
Exact-Rational
syntax
Real
syntax
Exact-Number
syntax
Float-Complex
syntax
Single-Flonum-Complex
syntax
Inexact-Complex
syntax
Imaginary
syntax
Exact-Complex
syntax
Exact-Imaginary
syntax
Inexact-Imaginary
syntax
Positive-Integer
syntax
Exact-Positive-Integer
syntax
Nonnegative-Integer
syntax
Exact-Nonnegative-Integer
syntax
Natural
syntax
Negative-Integer
syntax
Nonpositive-Integer
syntax
Zero
syntax
Positive-Float
syntax
Positive-Flonum
syntax
Nonnegative-Float
syntax
Nonnegative-Flonum
syntax
Negative-Float
syntax
Negative-Flonum
syntax
Nonpositive-Float
syntax
Nonpositive-Flonum
syntax
Float-Negative-Zero
syntax
Flonum-Negative-Zero
syntax
Float-Positive-Zero
syntax
Flonum-Positive-Zero
syntax
Float-Zero
syntax
Flonum-Zero
syntax
Float-Nan
syntax
Flonum-Nan
syntax
Positive-Single-Flonum
syntax
Nonnegative-Single-Flonum
syntax
Negative-Single-Flonum
syntax
Nonpositive-Single-Flonum
syntax
Single-Flonum-Negative-Zero
syntax
Single-Flonum-Positive-Zero
syntax
Single-Flonum-Zero
syntax
Single-Flonum-Nan
syntax
Positive-Inexact-Real
syntax
Nonnegative-Inexact-Real
syntax
Negative-Inexact-Real
syntax
Nonpositive-Inexact-Real
syntax
Inexact-Real-Negative-Zero
syntax
Inexact-Real-Positive-Zero
syntax
Inexact-Real-Zero
syntax
Inexact-Real-Nan
syntax
Positive-Exact-Rational
syntax
Nonnegative-Exact-Rational
syntax
Negative-Exact-Rational
syntax
Nonpositive-Exact-Rational
syntax
Positive-Real
syntax
Nonnegative-Real
syntax
Negative-Real
syntax
Nonpositive-Real
syntax
Real-Zero
syntax
One
syntax
Byte
syntax
Positive-Byte
syntax
Index
syntax
Positive-Index
syntax
Fixnum
syntax
Positive-Fixnum
syntax
Nonnegative-Fixnum
syntax
Negative-Fixnum
syntax
Nonpositive-Fixnum
syntax
ExtFlonum
syntax
Positive-ExtFlonum
syntax
Nonnegative-ExtFlonum
syntax
Negative-ExtFlonum
syntax
Nonpositive-ExtFlonum
syntax
ExtFlonum-Negative-Zero
syntax
ExtFlonum-Positive-Zero
syntax
ExtFlonum-Zero
syntax
ExtFlonum-Nan
syntax
Boolean
syntax
True
syntax
False
syntax
String
syntax
Keyword
syntax
Symbol
syntax
Char
syntax
Void
syntax
Input-Port
syntax
Output-Port
syntax
Port
syntax
Path
syntax
Path-For-Some-System
syntax
Regexp
syntax
PRegexp
syntax
Byte-Regexp
syntax
Byte-PRegexp
syntax
Bytes
syntax
Namespace
syntax
Namespace-Anchor
syntax
Variable-Reference
syntax
Null
syntax
EOF
syntax
Continuation-Mark-Set
syntax
Undefined
syntax
Module-Path
syntax
Module-Path-Index
syntax
Resolved-Module-Path
syntax
Compiled-Module-Expression
syntax
Compiled-Expression
syntax
Internal-Definition-Context
syntax
Pretty-Print-Style-Table
syntax
Special-Comment
syntax
Struct-Type-Property
syntax
Impersonator-Property
syntax
Read-Table
syntax
Bytes-Converter
syntax
Parameterization
syntax
Custodian
syntax
Inspector
syntax
Security-Guard
syntax
UDP-Socket
syntax
TCP-Listener
syntax
Logger
syntax
Log-Receiver
syntax
Log-Level
syntax
Thread
syntax
Thread-Group
syntax
Subprocess
syntax
Place
syntax
Place-Channel
syntax
Semaphore
syntax
FSemaphore
syntax
Will-Executor
syntax
Pseudo-Random-Generator
syntax
Environment-Variables
syntax
Path-String
syntax
(PairofÂ sÂ t)
syntax
(ListofÂ t)
syntax
(ListÂ tÂ ...)
syntax
(ListÂ tÂ ...Â trestÂ ...Â bound)
syntax
(List*Â tÂ t1Â ...Â s)
syntax
(MListofÂ t)
syntax
(MPairofÂ tÂ u)
syntax
MPairTop
syntax
(BoxofÂ t)
syntax
BoxTop
syntax
(VectorofÂ t)
syntax
(VectorÂ tÂ ...)
syntax
FlVector
syntax
ExtFlVector
syntax
FxVector
syntax
VectorTop
syntax
(Immutable-HashTableÂ kÂ v)
syntax
(Mutable-HashTableÂ kÂ v)
syntax
(Weak-HashTableÂ kÂ v)
syntax
(HashTableÂ kÂ v)
syntax
HashTableTop
syntax
Mutable-HashTableTop
syntax
Weak-HashTableTop
syntax
(SetofÂ t)
syntax
(ChannelofÂ t)
syntax
ChannelTop
syntax
(Async-ChannelofÂ t)
syntax
Async-ChannelTop
syntax
(ParameterofÂ t)
(ParameterofÂ sÂ t)
syntax
(PromiseÂ t)
syntax
(FutureofÂ t)
syntax
(SequenceofÂ t)
syntax
(Custodian-BoxofÂ t)
syntax
(Thread-CellofÂ t)
syntax
Thread-CellTop
syntax
(Weak-BoxofÂ t)
syntax
Weak-BoxTop
syntax
(EphemeronofÂ t)
syntax
(EvtofÂ t)
syntax
(SyntaxofÂ t)
syntax
Identifier
syntax
Syntax
syntax
Syntax-E
syntax
(SexpofÂ t)
syntax
Sexp
syntax
Datum
syntax
(Prompt-TagofÂ sÂ t)
syntax
Prompt-TagTop
syntax
(Continuation-Mark-KeyofÂ t)
syntax
Continuation-Mark-KeyTop
syntax
(->Â domÂ ...Â rngÂ opt-proposition)
(->Â domÂ ...Â restÂ *Â rng)
(->Â domÂ ...Â restÂ oooÂ boundÂ rng)
(domÂ ...Â ->Â rngÂ opt-proposition)
(domÂ ...Â restÂ *Â ->Â rng)
(domÂ ...Â restÂ oooÂ boundÂ ->Â rng)
Â 
            oooÂ =Â ...
              Â Â Â Â Â 
            domÂ =Â type
              Â Â |Â mandatory-kw
              Â Â |Â opt-kw
              Â Â Â Â Â 
   mandatory-kwÂ =Â keywordÂ type
              Â Â Â Â Â 
         opt-kwÂ =Â [keywordÂ type]
              Â Â Â Â Â 
opt-propositionÂ =Â 
              Â Â |Â :Â type
              Â Â |Â :Â pos-proposition
                  Â Â neg-proposition
                  Â Â object
              Â Â Â Â Â 
pos-propositionÂ =Â 
              Â Â |Â #:+Â propositionÂ ...
              Â Â Â Â Â 
neg-propositionÂ =Â 
              Â Â |Â #:-Â propositionÂ ...
              Â Â Â Â Â 
         objectÂ =Â 
              Â Â |Â #:objectÂ index
              Â Â Â Â Â 
    propositionÂ =Â Top
              Â Â |Â Bot
              Â Â |Â type
              Â Â |Â (!Â type)
              Â Â |Â (typeÂ @Â path-elemÂ ...Â index)
              Â Â |Â (!Â typeÂ @Â path-elemÂ ...Â index)
              Â Â |Â (andÂ propositionÂ ...)
              Â Â |Â (orÂ propositionÂ ...)
              Â Â |Â (impliesÂ propositionÂ ...)
              Â Â Â Â Â 
      path-elemÂ =Â car
              Â Â |Â cdr
              Â Â Â Â Â 
          indexÂ =Â positive-integer
              Â Â |Â (positive-integerÂ positive-integer)
              Â Â |Â identifier
syntax
(->*Â (mandatory-domÂ ...)Â optional-domsÂ restÂ rng)
Â 
mandatory-domÂ =Â type
            Â Â |Â keywordÂ type
            Â Â Â Â Â 
optional-domsÂ =Â 
            Â Â |Â (optional-domÂ ...)
            Â Â Â Â Â 
 optional-domÂ =Â type
            Â Â |Â keywordÂ type
            Â Â Â Â Â 
         restÂ =Â 
            Â Â |Â #:restÂ type
            Â Â |Â #:rest-starÂ (typeÂ ...)
syntax
Top
syntax
Bot
syntax
Procedure
syntax
(UÂ tÂ ...)
syntax
(âˆ©Â tÂ ...)
syntax
(case->Â fun-tyÂ ...)
syntax
(tÂ t1Â t2Â ...)
syntax
(AllÂ (aÂ ...)Â t)
(AllÂ (aÂ ...Â aÂ ooo)Â t)
syntax
(ValuesÂ tÂ ...)
syntax
v
syntax
(quoteÂ val)
syntax
i
syntax
(RecÂ nÂ t)
syntax
(StructÂ st)
syntax
(Struct-TypeÂ st)
syntax
Struct-TypeTop
syntax
(PrefabÂ keyÂ typeÂ ...)
syntax
(PrefabTopÂ keyÂ field-count)
syntax
Union
syntax
Intersection
syntax
â†’
syntax
caseâ†’
syntax
âˆ€
syntax
(OptionÂ t)
syntax
(OpaqueÂ t)
syntax
(letÂ maybe-tvarsÂ (bindingÂ ...)Â . body)
(letÂ loopÂ maybe-retÂ (bindingÂ ...)Â . body)
Â 
    bindingÂ =Â [varÂ e]
          Â Â |Â [varÂ :Â typeÂ e]
          Â Â Â Â Â 
maybe-tvarsÂ =Â 
          Â Â |Â #:forallÂ (tvarÂ ...)
          Â Â |Â #:âˆ€Â (tvarÂ ...)
          Â Â Â Â Â 
  maybe-retÂ =Â 
          Â Â |Â :Â type0
syntax
(letrecÂ (bindingÂ ...)Â . body)
syntax
(let*Â (bindingÂ ...)Â . body)
syntax
(let-valuesÂ ([(var+typeÂ ...)Â e]Â ...)Â . body)
syntax
(letrec-valuesÂ ([(var+typeÂ ...)Â e]Â ...)Â . body)
syntax
(let*-valuesÂ ([(var+typeÂ ...)Â e]Â ...)Â . body)
syntax
(let/ccÂ vÂ :Â tÂ . body)
syntax
(let/ecÂ vÂ :Â tÂ . body)
syntax
(lambdaÂ maybe-tvarsÂ formalsÂ maybe-retÂ . body)
Â 
    formalsÂ =Â (formalÂ ...)
          Â Â |Â (formalÂ ...Â . rst)
          Â Â Â Â Â 
     formalÂ =Â var
          Â Â |Â [varÂ default-expr]
          Â Â |Â [varÂ :Â type]
          Â Â |Â [varÂ :Â typeÂ default-expr]
          Â Â |Â keywordÂ var
          Â Â |Â keywordÂ [varÂ :Â type]
          Â Â |Â keywordÂ [varÂ :Â typeÂ default-expr]
          Â Â Â Â Â 
        rstÂ =Â var
          Â Â |Â [varÂ :Â typeÂ *]
          Â Â |Â [varÂ :Â typeÂ oooÂ bound]
          Â Â Â Â Â 
maybe-tvarsÂ =Â 
          Â Â |Â #:forallÂ (tvarÂ ...)
          Â Â |Â #:âˆ€Â (tvarÂ ...)
          Â Â |Â #:forallÂ (tvarÂ ...Â ooo)
          Â Â |Â #:âˆ€Â (tvarÂ ...Â ooo)
          Â Â Â Â Â 
  maybe-retÂ =Â 
          Â Â |Â :Â type
syntax
(Î»Â formalsÂ . body)
syntax
(case-lambdaÂ maybe-tvarsÂ [formalsÂ body]Â ...)
syntax
(forÂ type-ann-maybeÂ (for-clauseÂ ...)
Â Â exprÂ ...+)
Â 
type-ann-maybeÂ =Â 
             Â Â |Â :Â u
             Â Â Â Â Â 
    for-clauseÂ =Â [idÂ :Â tÂ seq-expr]
             Â Â |Â [(bindingÂ ...)Â seq-expr]
             Â Â |Â [idÂ seq-expr]
             Â Â |Â #:whenÂ guard
             Â Â Â Â Â 
       bindingÂ =Â id
             Â Â |Â [idÂ :Â t]
syntax
(for/listÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/hashÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/hasheqÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/hasheqvÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/vectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/orÂ Â Â type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/sumÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/productÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/setÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/listÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/hashÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/hasheqÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/hasheqvÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/vectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/orÂ Â Â type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/sumÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/productÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/setÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/andÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/firstÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/lastÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/andÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/firstÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/lastÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/listsÂ type-ann-maybeÂ ([idÂ :Â t]Â ...)
Â Â (for-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for/foldÂ Â type-ann-maybeÂ ([idÂ :Â tÂ init-expr]Â ...)
Â Â (for-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for*Â void-ann-maybeÂ (for-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for*/listsÂ type-ann-maybeÂ ([idÂ :Â t]Â ...)
Â Â (for-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for*/foldÂ Â type-ann-maybeÂ ([idÂ :Â tÂ init-expr]Â ...)
Â Â (for-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(doÂ :Â uÂ ([idÂ :Â tÂ init-exprÂ step-expr-maybe]Â ...)
Â Â Â Â Â Â Â Â (stop?-exprÂ finish-exprÂ ...)
Â Â exprÂ ...+)
Â 
step-expr-maybeÂ =Â 
              Â Â |Â step-expr
syntax
(defineÂ maybe-tvarsÂ vÂ maybe-annÂ e)
(defineÂ maybe-tvarsÂ headerÂ maybe-annÂ . body)
Â 
     headerÂ =Â (function-nameÂ . formals)
          Â Â |Â (headerÂ . formals)
          Â Â Â Â Â 
    formalsÂ =Â (formalÂ ...)
          Â Â |Â (formalÂ ...Â . rst)
          Â Â Â Â Â 
     formalÂ =Â var
          Â Â |Â [varÂ default-expr]
          Â Â |Â [varÂ :Â type]
          Â Â |Â [varÂ :Â typeÂ default-expr]
          Â Â |Â keywordÂ var
          Â Â |Â keywordÂ [varÂ :Â type]
          Â Â |Â keywordÂ [varÂ :Â typeÂ default-expr]
          Â Â Â Â Â 
        rstÂ =Â var
          Â Â |Â [varÂ :Â typeÂ *]
          Â Â |Â [varÂ :Â typeÂ oooÂ bound]
          Â Â Â Â Â 
maybe-tvarsÂ =Â 
          Â Â |Â #:forallÂ (tvarÂ ...)
          Â Â |Â #:âˆ€Â (tvarÂ ...)
          Â Â |Â #:forallÂ (tvarÂ ...Â ooo)
          Â Â |Â #:âˆ€Â (tvarÂ ...Â ooo)
          Â Â Â Â Â 
  maybe-annÂ =Â 
          Â Â |Â :Â type
syntax
(structÂ maybe-type-varsÂ name-specÂ ([fÂ :Â t]Â ...)Â optionsÂ ...)
Â 
maybe-type-varsÂ =Â 
              Â Â |Â (vÂ ...)
              Â Â Â Â Â 
      name-specÂ =Â name-id
              Â Â |Â name-idÂ parent
              Â Â Â Â Â 
        optionsÂ =Â #:transparent
              Â Â |Â #:mutable
              Â Â |Â #:prefab
              Â Â |Â #:constructor-nameÂ constructor-id
              Â Â |Â #:extra-constructor-nameÂ constructor-id
              Â Â |Â #:type-nameÂ type-id
syntax
(define-structÂ maybe-type-varsÂ name-specÂ ([fÂ :Â t]Â ...)Â optionsÂ ...)
Â 
maybe-type-varsÂ =Â 
              Â Â |Â (vÂ ...)
              Â Â Â Â Â 
      name-specÂ =Â name-id
              Â Â |Â name-idÂ parent
              Â Â Â Â Â 
        optionsÂ =Â #:transparent
              Â Â |Â #:mutable
              Â Â |Â #:type-nameÂ type-id
syntax
(define-struct/execÂ name-specÂ ([fÂ :Â t]Â ...)Â [eÂ :Â proc-t]Â maybe-type-name)
Â 
      name-specÂ =Â name-id
              Â Â |Â name-idÂ parent
              Â Â Â Â Â 
maybe-type-nameÂ =Â 
              Â Â |Â #:type-nameÂ type-id
syntax
(define-typeÂ nameÂ tÂ maybe-omit-def)
(define-typeÂ (nameÂ vÂ ...)Â tÂ maybe-omit-def)
Â 
maybe-omit-defÂ =Â #:omit-define-syntaxes
             Â Â |Â 
syntax
(make-predicateÂ t)
syntax
(define-predicateÂ nameÂ t)
syntax
(:Â vÂ t)
(:Â vÂ :Â t)
syntax
(provide:Â [vÂ t]Â ...)
syntax
#{vÂ :Â t}
syntax
(annÂ eÂ t)
syntax
#{eÂ ::Â t}
syntax
(castÂ eÂ t)
syntax
(instÂ eÂ tÂ ...)
(instÂ eÂ tÂ ...Â tÂ oooÂ bound)
syntax
(row-instÂ eÂ row)
syntax
#{eÂ @Â tÂ ...}
syntax
#{eÂ @Â tÂ ...Â tÂ oooÂ bound}
syntax
(require/typedÂ mÂ rt-clauseÂ ...)
Â 
    rt-clauseÂ =Â [maybe-renamedÂ t]
            Â Â |Â [#:structÂ maybe-tvarsÂ name-idÂ ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [#:structÂ maybe-tvarsÂ (name-idÂ parent)Â ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [#:opaqueÂ tÂ pred]
            Â Â |Â [#:signatureÂ nameÂ ([idÂ :Â t]Â ...)]
            Â Â Â Â Â 
maybe-renamedÂ =Â id
            Â Â |Â (orig-idÂ new-id)
            Â Â Â Â Â 
  maybe-tvarsÂ =Â 
            Â Â |Â (type-variableÂ ...)
            Â Â Â Â Â 
struct-optionÂ =Â #:constructor-nameÂ constructor-id
            Â Â |Â #:extra-constructor-nameÂ constructor-id
            Â Â |Â #:type-nameÂ type-id
syntax
(require/typed/provideÂ mÂ rt-clauseÂ ...)
syntax
with-handlers
procedure
(default-continuation-prompt-tag)
Â ->Â (->Â (Prompt-TagofÂ AnyÂ (AnyÂ ->Â Any)))
syntax
(#%module-beginÂ formÂ ...)
syntax
(#%top-interactionÂ . form)
type
GIF-Stream
type
GIF-Colormap
type
JSExpr
type
Cookie
type
FTP-Connection
type
HTTP-Connection
type
IMAP-Connection
type
Path/Param
type
URL
type
URL-Exception
type
PortT
type
PortT/Bytes
type
SSL-Protocol
type
SSL-Server-Context
type
SSL-Client-Context
type
SSL-Context
type
SSL-Listener
type
SSL-Verify-Source
syntax
(for/extflvectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/extflvectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/flvectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/flvectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
type
Char-Set
type
Cursor
type
Time
type
Date
syntax
(classÂ superclass-expr
Â Â maybe-type-parameters
Â Â class-clauseÂ ...)
Â 
         class-clauseÂ =Â (inspectÂ inspector-expr)
                    Â Â |Â (initÂ init-declÂ ...)
                    Â Â |Â (init-fieldÂ init-declÂ ...)
                    Â Â |Â (init-restÂ id/type)
                    Â Â |Â (fieldÂ field-declÂ ...)
                    Â Â |Â (inherit-fieldÂ field-declÂ ...)
                    Â Â |Â (publicÂ maybe-renamed/typeÂ ...)
                    Â Â |Â (pubmentÂ maybe-renamed/typeÂ ...)
                    Â Â |Â (overrideÂ maybe-renamed/typeÂ ...)
                    Â Â |Â (augmentÂ maybe-renamed/typeÂ ...)
                    Â Â |Â (privateÂ id/typeÂ ...)
                    Â Â |Â (inheritÂ idÂ ...)
                    Â Â |Â method-definition
                    Â Â |Â definition
                    Â Â |Â expr
                    Â Â |Â (beginÂ class-clauseÂ ...)
                    Â Â Â Â Â 
maybe-type-parametersÂ =Â 
                    Â Â |Â #:forallÂ (type-variableÂ ...)
                    Â Â |Â #:âˆ€Â (type-variableÂ ...)
                    Â Â Â Â Â 
            init-declÂ =Â id/type
                    Â Â |Â [renamed]
                    Â Â |Â [renamedÂ :Â type-expr]
                    Â Â |Â [maybe-renamedÂ default-value-expr]
                    Â Â |Â [maybe-renamedÂ :Â type-exprÂ default-value-expr]
                    Â Â Â Â Â 
           field-declÂ =Â (maybe-renamedÂ default-value-expr)
                    Â Â |Â (maybe-renamedÂ :Â type-exprÂ default-value-expr)
                    Â Â Â Â Â 
              id/typeÂ =Â id
                    Â Â |Â [idÂ :Â type-expr]
                    Â Â Â Â Â 
   maybe-renamed/typeÂ =Â maybe-renamed
                    Â Â |Â [maybe-renamedÂ :Â type-expr]
                    Â Â Â Â Â 
        maybe-renamedÂ =Â id
                    Â Â |Â renamed
                    Â Â Â Â Â 
              renamedÂ =Â (internal-idÂ external-id)
syntax
(define/publicÂ idÂ expr)
(define/publicÂ (idÂ . formals)Â bodyÂ ...+)
syntax
(define/overrideÂ idÂ expr)
(define/overrideÂ (idÂ . formals)Â bodyÂ ...+)
syntax
(define/pubmentÂ idÂ expr)
(define/pubmentÂ (idÂ . formals)Â bodyÂ ...+)
syntax
(define/augmentÂ idÂ expr)
(define/augmentÂ (idÂ . formals)Â bodyÂ ...+)
syntax
(define/privateÂ idÂ expr)
(define/privateÂ (idÂ . formals)Â bodyÂ ...+)
syntax
(initÂ init-declÂ ...)
syntax
(init-fieldÂ init-declÂ ...)
syntax
(fieldÂ field-declÂ ...)
syntax
(inherit-fieldÂ field-declÂ ...)
syntax
(init-restÂ id/type)
syntax
(publicÂ maybe-renamed/typeÂ ...)
syntax
(pubmentÂ maybe-renamed/typeÂ ...)
syntax
(overrideÂ maybe-renamed/typeÂ ...)
syntax
(augmentÂ maybe-renamed/typeÂ ...)
syntax
(privateÂ id/typeÂ ...)
syntax
(inheritÂ maybe-renamed/typeÂ ...)
syntax
(ClassÂ class-type-clauseÂ ...)
Â 
class-type-clauseÂ =Â name+type
                Â Â |Â (initÂ init-typeÂ ...)
                Â Â |Â (init-fieldÂ init-typeÂ ...)
                Â Â |Â (init-restÂ name+type)
                Â Â |Â (fieldÂ name+typeÂ ...)
                Â Â |Â (augmentÂ name+typeÂ ...)
                Â Â |Â #:implementsÂ type-alias-id
                Â Â |Â #:implements/initsÂ inits-id
                Â Â |Â #:row-varÂ row-var-id
                Â Â Â Â Â 
        init-typeÂ =Â name+type
                Â Â |Â [idÂ typeÂ #:optional]
                Â Â Â Â Â 
        name+typeÂ =Â [idÂ type]
syntax
ClassTop
syntax
(ObjectÂ object-type-clauseÂ ...)
Â 
object-type-clauseÂ =Â name+type
                 Â Â |Â (fieldÂ name+typeÂ ...)
syntax
(InstanceÂ class-type-expr)
syntax
(RowÂ class-type-clauseÂ ...)
syntax
(define-signatureÂ idÂ extension-decl
Â Â (sig-elemÂ ...))
Â 
extension-declÂ =Â 
             Â Â |Â extendsÂ sig-id
             Â Â Â Â Â 
      sig-elemÂ =Â [idÂ :Â type]
syntax
(unit
Â Â (importÂ sig-specÂ ...)
Â Â (exportÂ sig-specÂ ...)
Â Â init-depends-decl
Â Â unit-body-expr-or-defn
Â Â ...)
Â 
         sig-specÂ =Â sig-id
                Â Â |Â (prefixÂ idÂ sig-spec)
                Â Â |Â (renameÂ sig-specÂ (idÂ id)Â ...)
                Â Â |Â (onlyÂ sig-specÂ idÂ ...)
                Â Â |Â (exceptÂ sig-specÂ idÂ ...)
                Â Â Â Â Â 
init-depends-declÂ =Â 
                Â Â |Â (init-dependÂ sig-idÂ ...)
syntax
(invoke-unitÂ unit-expr)
(invoke-unitÂ unit-exprÂ (importÂ sig-specÂ ...))
syntax
(define-values/invoke-unitÂ unit-expr
Â Â (importÂ def-sig-specÂ ...)
Â Â (exportÂ def-sig-specÂ ...))
Â 
def-sig-specÂ =Â sig-id
           Â Â |Â (prefixÂ idÂ def-sig-spec)
           Â Â |Â (renameÂ def-sig-specÂ (idÂ id)Â ...)
syntax
(compound-unit
Â Â (importÂ link-bindingÂ ...)
Â Â (exportÂ link-idÂ ...)
Â Â (linkÂ linkage-declÂ ...))
Â 
link-bindingÂ =Â (link-idÂ :Â sig-id)
           Â Â Â Â Â 
linkage-declÂ =Â ((link-bindingÂ ...)Â unit-exprÂ link-idÂ ...)
syntax
(define-unitÂ unit-id
Â Â (importÂ sig-specÂ ...)
Â Â (exportÂ sig-specÂ ...)
Â Â init-depends-decl
Â Â unit-body-expr-or-defn
Â Â ...)
syntax
(compound-unit/infer
Â Â (importÂ infer-link-importÂ ...)
Â Â (exportÂ infer-link-exportÂ ...)
Â Â (linkÂ infer-linkage-declÂ ...))
Â 
 infer-link-importÂ =Â sig-id
                 Â Â |Â (link-idÂ :Â sig-id)
                 Â Â Â Â Â 
 infer-link-exportÂ =Â link-id
                 Â Â |Â sig-id
                 Â Â Â Â Â 
infer-linkage-declÂ =Â ((link-bindingÂ ...)Â unit-id
                     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tagged-link-idÂ ...)
                 Â Â |Â unit-id
syntax
(define-compound-unitÂ id
Â Â (importÂ link-bindingÂ ...)
Â Â (exportÂ link-idÂ ...)
Â Â (linkÂ linkage-declÂ ...))
syntax
(define-compound-unit/inferÂ id
Â Â (importÂ link-bindingÂ ...)
Â Â (exportÂ infer-link-exportÂ ...)
Â Â (linkÂ infer-linkage-declÂ ...))
syntax
(invoke-unit/inferÂ unit-spec)
Â 
unit-specÂ =Â unit-id
        Â Â |Â (linkÂ link-unit-idÂ ...)
syntax
(define-values/invoke-unit/inferÂ maybe-exportsÂ unit-spec)
Â 
maybe-exportsÂ =Â 
            Â Â |Â (exportÂ sig-sepcÂ ...)
            Â Â Â Â Â 
    unit-specÂ =Â unit-id
            Â Â |Â (linkÂ link-unit-idÂ ...)
syntax
(unit-from-contextÂ sig-spec)
syntax
(define-unit-from-contextÂ idÂ sig-spec)
syntax
(Unit
Â Â (importÂ sig-idÂ ...)
Â Â (exportÂ sig-idÂ ...)
Â Â optional-init-depend-clause
Â Â optional-body-type-clause)
Â 
optional-init-depend-clauseÂ =Â 
                          Â Â |Â (init-dependÂ sig-idÂ ...)
                          Â Â Â Â Â 
  optional-body-type-clauseÂ =Â 
                          Â Â |Â type
                          Â Â |Â (ValuesÂ typeÂ ...)
syntax
UnitTop
syntax
(require/typedÂ mÂ rt-clauseÂ ...)
Â 
    rt-clauseÂ =Â [maybe-renamedÂ t]
            Â Â |Â [#:structÂ nameÂ ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [#:structÂ (nameÂ parent)Â ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [#:opaqueÂ tÂ pred]
            Â Â |Â [#:signatureÂ nameÂ ([idÂ :Â t]Â ...)]
            Â Â Â Â Â 
maybe-renamedÂ =Â id
            Â Â |Â (orig-idÂ new-id)
            Â Â Â Â Â 
struct-optionÂ =Â #:constructor-nameÂ constructor-id
            Â Â |Â #:extra-constructor-nameÂ constructor-id
procedure
(assertÂ v)Â ->Â A
Â Â vÂ :Â (UÂ #fÂ A)
(assertÂ vÂ p?)Â ->Â B
Â Â vÂ :Â A
Â Â p?Â :Â (AÂ ->Â AnyÂ :Â B)
syntax
(with-assertsÂ ([idÂ maybe-pred]Â ...)Â bodyÂ ...+)
Â 
maybe-predÂ =Â 
         Â Â |Â predicate
procedure
(defined?Â v)Â ->Â boolean?
Â Â vÂ :Â any/c
procedure
(index?Â v)Â ->Â boolean?
Â Â vÂ :Â any/c
syntax
(typecheck-failÂ orig-stxÂ maybe-msgÂ maybe-id)
Â 
maybe-msgÂ =Â 
        Â Â |Â msg-string
        Â Â Â Â Â 
 maybe-idÂ =Â 
        Â Â |Â #:covered-idÂ id
syntax
(assert-typecheck-failÂ body-expr)
(assert-typecheck-failÂ body-exprÂ #:resultÂ result-expr)
syntax
(require/untyped-contractÂ maybe-beginÂ moduleÂ [nameÂ subtype]Â ...)
Â 
maybe-beginÂ =Â 
          Â Â |Â (beginÂ exprÂ ...)
syntax
(define-typed/untyped-identifierÂ nameÂ typed-nameÂ untyped-name)
procedure
(syntax-local-typed-context?)Â ->Â boolean?
syntax
(:typeÂ maybe-verboseÂ t)
Â 
maybe-verboseÂ =Â 
            Â Â |Â #:verbose
syntax
(:print-typeÂ e)
syntax
(:query-type/argsÂ fÂ tÂ ...)
syntax
(:query-type/resultÂ fÂ t)
syntax
(with-typeÂ result-specÂ fv-clauseÂ bodyÂ ...+)
(with-typeÂ export-specÂ fv-clauseÂ bodyÂ ...+)
Â 
  fv-clauseÂ =Â 
          Â Â |Â #:freevarsÂ ([idÂ fv-type]Â ...)
          Â Â Â Â Â 
result-specÂ =Â #:resultÂ type
          Â Â Â Â Â 
export-specÂ =Â ([export-idÂ export-type]Â ...)
syntax
(unsafe-require/typedÂ mÂ rt-clauseÂ ...)
syntax
(unsafe-provideÂ provide-specÂ ...)
syntax
(unsafe-require/typed/provideÂ mÂ rt-clauseÂ ...)
syntax
(lambda:Â formalsÂ . body)
Â 
formalsÂ =Â ([vÂ :Â t]Â ...)
      Â Â |Â ([vÂ :Â t]Â ...Â vÂ :Â tÂ *)
      Â Â |Â ([vÂ :Â t]Â ...Â vÂ :Â tÂ oooÂ bound)
syntax
(Î»:Â formalsÂ . body)
syntax
(plambda:Â (aÂ ...)Â formalsÂ . body)
(plambda:Â (aÂ ...Â bÂ ooo)Â formalsÂ . body)
syntax
(opt-lambda:Â formalsÂ . body)
Â 
formalsÂ =Â ([vÂ :Â t]Â ...Â [vÂ :Â tÂ default]Â ...)
      Â Â |Â ([vÂ :Â t]Â ...Â [vÂ :Â tÂ default]Â ...Â vÂ :Â tÂ *)
      Â Â |Â ([vÂ :Â t]Â ...Â [vÂ :Â tÂ default]Â ...Â vÂ :Â tÂ oooÂ bound)
syntax
(popt-lambda:Â (aÂ ...)Â formalsÂ . body)
(popt-lambda:Â (aÂ ...Â aÂ ooo)Â formalsÂ . body)
syntax
case-lambda:
syntax
(pcase-lambda:Â (aÂ ...)Â [formalsÂ body]Â ...)
(pcase-lambda:Â (aÂ ...Â bÂ ooo)Â [formalsÂ body]Â ...)
syntax
(let:Â ([vÂ :Â tÂ e]Â ...)Â . body)
(let:Â loopÂ :Â t0Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(plet:Â (aÂ ...)Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(letrec:Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(let*:Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(let-values:Â ([([vÂ :Â t]Â ...)Â e]Â ...)Â . body)
syntax
(letrec-values:Â ([([vÂ :Â t]Â ...)Â e]Â ...)Â . body)
syntax
(let*-values:Â ([([vÂ :Â t]Â ...)Â e]Â ...)Â . body)
syntax
(let/cc:Â vÂ :Â tÂ . body)
syntax
(let/ec:Â vÂ :Â tÂ . body)
syntax
(define:Â vÂ :Â tÂ e)
(define:Â (aÂ ...)Â vÂ :Â tÂ e)
(define:Â (aÂ ...Â aÂ ooo)Â vÂ :Â tÂ e)
(define:Â (fÂ . formals)Â :Â tÂ . body)
(define:Â (aÂ ...)Â (fÂ . formals)Â :Â tÂ . body)
(define:Â (aÂ ...Â aÂ ooo)Â (fÂ . formals)Â :Â tÂ . body)
syntax
struct:
syntax
define-struct:
syntax
define-struct/exec:
syntax
for:
syntax
for*/and:
syntax
for*/first:
syntax
for*/flvector:
syntax
for*/extflvector:
syntax
for*/fold:
syntax
for*/hash:
syntax
for*/hasheq:
syntax
for*/hasheqv:
syntax
for*/last:
syntax
for*/list:
syntax
for*/lists:
syntax
for*/set:
syntax
for*/or:
syntax
for*/product:
syntax
for*/sum:
syntax
for*/vector:
syntax
for*:
syntax
for/and:
syntax
for/first:
syntax
for/flvector:
syntax
for/extflvector:
syntax
for/fold:
syntax
for/hash:
syntax
for/hasheq:
syntax
for/hasheqv:
syntax
for/last:
syntax
for/list:
syntax
for/lists:
syntax
for/set:
syntax
for/or:
syntax
for/product:
syntax
for/sum:
syntax
for/vector:
syntax
do:
syntax
define-type-alias
syntax
define-typed-struct
syntax
require/opaque-type
syntax
require-typed-struct
syntax
require-typed-struct/provide
syntax
pdefine:
syntax
(predÂ t)
syntax
Un
syntax
mu
syntax
Tuple
syntax
Parameter
syntax
Pair
syntax
values
syntax
(require/typedÂ mÂ rt-clauseÂ ...)
Â 
    rt-clauseÂ =Â [rÂ t]
            Â Â |Â [structÂ nameÂ ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [structÂ (nameÂ parent)Â ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [opaqueÂ tÂ pred]
            Â Â Â Â Â 
struct-optionÂ =Â #:constructor-nameÂ constructor-id
            Â Â |Â #:extra-constructor-nameÂ constructor-id
syntax
require-typed-struct
syntax
(declare-refinementÂ id)
syntax
(RefinementÂ id)
syntax
(define-typed-struct/execÂ formsÂ ...)
syntax
(define-new-subtypeÂ nameÂ (constructorÂ t))
syntax
(RefineÂ [idÂ :Â type]Â proposition)
Â 
    propositionÂ =Â Top
              Â Â |Â Bot
              Â Â |Â (:Â symbolic-objectÂ type)
              Â Â |Â (!Â symbolic-objectÂ type)
              Â Â |Â (andÂ propositionÂ ...)
              Â Â |Â (orÂ propositionÂ ...)
              Â Â |Â (whenÂ propositionÂ proposition)
              Â Â |Â (unlessÂ propositionÂ proposition)
              Â Â |Â (ifÂ propositionÂ propositionÂ proposition)
              Â Â |Â (linear-compÂ symbolic-objectÂ symbolic-object)
              Â Â Â Â Â 
    linear-compÂ =Â <
              Â Â |Â <=
              Â Â |Â =
              Â Â |Â >=
              Â Â |Â >
              Â Â Â Â Â 
symbolic-objectÂ =Â exact-integer
              Â Â |Â symbolic-path
              Â Â |Â (+Â symbolic-objectÂ ...)
              Â Â |Â (-Â symbolic-objectÂ ...)
              Â Â |Â (*Â exact-integerÂ symbolic-object)
              Â Â Â Â Â 
  symbolic-pathÂ =Â id
              Â Â |Â (path-elemÂ symbolic-path)
              Â Â Â Â Â 
      path-elemÂ =Â car
              Â Â |Â cdr
              Â Â |Â vector-length
syntax
(!Â sym-objÂ type)
syntax
(->Â ([idÂ :Â opt-depsÂ arg-type]Â ...)
Â Â Â Â opt-pre
Â Â Â Â range-type
Â Â Â Â opt-props)
Â 
    opt-depsÂ =Â 
           Â Â |Â (idÂ ...)
           Â Â Â Â Â 
     opt-preÂ =Â 
           Â Â |Â #:preÂ (idÂ ...)Â prop
           Â Â Â Â Â 
   opt-propsÂ =Â 
           Â Â |Â opt-pos-propÂ opt-neg-propÂ opt-obj
           Â Â Â Â Â 
opt-pos-propÂ =Â 
           Â Â |Â #:+Â prop
           Â Â Â Â Â 
opt-neg-propÂ =Â 
           Â Â |Â #:-Â prop
           Â Â Â Â Â 
     opt-objÂ =Â 
           Â Â |Â #:objectÂ obj
